<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>40 Interactive Data Visualization Templates</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Base styles consistent with previous versions and ecomerce.html */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light slate background */
            color: #1e293b; /* Dark slate text */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark body {
            background-color: #0f172a; /* Darker slate background */
            color: #e2e8f0; /* Light slate text */
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .section-title {
            font-size: 2.75rem; /* 4xl */
            font-weight: 800; /* Extra bold */
            text-align: center;
            margin-bottom: 1.5rem;
            background: linear-gradient(45deg, #10b981, #3b82f6); /* Green to Blue gradient for Visualizations */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            display: inline-block;
            padding-bottom: 0.5rem;
        }
        .section-title::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
            width: 100px;
            height: 5px;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            border-radius: 2px;
        }

        .chart-card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin-bottom: 3rem;
            transition: all 0.3s ease-in-out;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }
        .dark .chart-card {
            background-color: #1e293b;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            border-color: #334155;
        }
        .chart-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.15);
        }
        .dark .chart-card:hover {
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.4);
        }

        .chart-card h2 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #334155;
            text-align: center;
        }
        .dark .chart-card h2 {
            color: #f8fafc;
        }

        .chart-container {
            width: 100%;
            height: 400px; /* Fixed height for consistency */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8fafc;
            border-radius: 1rem;
            border: 1px solid #cbd5e1;
            overflow: hidden;
        }
        .dark .chart-container {
            background-color: #0f172a;
            border-color: #475569;
        }
        .chart-container svg {
            overflow: visible; /* Allow elements to extend slightly for labels/tooltips */
        }
        .chart-container canvas {
            display: block; /* Ensure canvas takes full space */
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .button-group button {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, #10b981, #3b82f6); /* Green to Blue */
            color: white;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
            border: none;
            cursor: pointer;
        }
        .dark .button-group button {
            background: linear-gradient(45deg, #3b82f6, #60a5fa);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.3);
        }
        .button-group button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
        }
        .dark .button-group button:hover {
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }

        /* Code display styles */
        .code-container {
            background-color: #1e293b;
            color: #e2e8f0;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1.5rem;
            overflow-x: auto;
            max-height: 300px; /* Limit height for code block */
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.875rem;
            line-height: 1.5;
            display: none; /* Hidden by default */
        }
        .code-container.open {
            display: block;
        }
        .dark .code-container {
            background-color: #0f172a;
            border: 1px solid #334155;
        }

        /* Message Box styles */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .message-box-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .message-box-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .dark .message-box-content {
            background-color: #1e293b;
        }
        .message-box-overlay.open .message-box-content {
            transform: translateY(0);
            opacity: 1;
        }
        .message-box-button {
            background-color: #3b82f6; /* Adjusted for visualization theme */
            color: white;
            padding: 0.6rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            margin-top: 1.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .dark .message-box-button {
            background-color: #60a5fa; /* Adjusted for visualization theme */
        }
        .message-box-button:hover {
            background-color: #2563eb;
        }
        .dark .message-box-button:hover {
            background-color: #3b82f6;
        }

        /* Search Bar Only Header */
        .simplified-header {
            background-color: #ffffff;
            padding: 1.5rem 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .dark .simplified-header {
            background-color: #1e293b;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .simplified-header .search-container {
            position: relative;
            width: 80%;
            max-width: 600px;
        }

        .simplified-header input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 3rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            font-size: 1rem;
            color: #1e293b;
            background-color: #f8fafc;
            transition: all 0.3s ease;
        }
        .dark .simplified-header input {
            background-color: #334155;
            border-color: #475569;
            color: #e2e8f0;
            placeholder-color: #94a3b8;
        }

        .simplified-header input:focus {
            outline: none;
            border-color: #10b981; /* Focus color - adjusted for visualization theme */
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
        }
        .dark .simplified-header input:focus {
            border-color: #3b82f6; /* Focus color - adjusted for visualization theme */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .simplified-header .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
        }
        .dark .simplified-header .search-icon {
            color: #94a3b8;
        }

        /* Specific chart styles (D3.js) */
        .bar-chart rect { fill: url(#barGradient); transition: fill 0.3s ease, height 0.5s ease-out; }
        .bar-chart rect:hover { fill: url(#barHoverGradient); }
        .line-chart path { fill: none; stroke: url(#lineGradient); stroke-width: 4; transition: stroke 0.3s ease; }
        .line-chart circle { fill: #3b82f6; stroke: white; stroke-width: 2; transition: r 0.2s ease; }
        .line-chart circle:hover { r: 8; }
        .pie-chart path { transition: fill 0.3s ease, transform 0.3s ease; }
        .pie-chart path:hover { transform: scale(1.03); filter: brightness(1.1); }
        .donut-chart path { transition: fill 0.3s ease, transform 0.3s ease; }
        .donut-chart path:hover { transform: scale(1.03); filter: brightness(1.1); }
        .area-chart path { fill: url(#areaGradient); stroke: #3b82f6; stroke-width: 2; transition: fill 0.3s ease; }
        .scatter-plot circle { fill: url(#scatterGradient); opacity: 0.8; transition: r 0.2s ease, opacity 0.2s ease; }
        .scatter-plot circle:hover { r: 8; opacity: 1; }
        .bubble-chart circle { fill: url(#bubbleGradient); opacity: 0.7; stroke: white; stroke-width: 1; transition: r 0.2s ease, opacity 0.2s ease; }
        .bubble-chart circle:hover { opacity: 1; stroke-width: 2; }
        .radar-chart line { stroke: #cbd5e1; stroke-width: 1; }
        .radar-chart path.area { fill: url(#radarGradient); opacity: 0.7; transition: opacity 0.3s ease; }
        .radar-chart path.line { fill: none; stroke: #3b82f6; stroke-width: 2; }
        .radar-chart circle { fill: #3b82f6; stroke: white; stroke-width: 1; }
        .heatmap rect { transition: fill 0.3s ease; }
        .heatmap rect:hover { filter: brightness(1.2); }
        .treemap rect { transition: fill 0.3s ease, stroke 0.3s ease; }
        .treemap rect:hover { stroke: white; stroke-width: 2; filter: brightness(1.1); }
        .gauge-chart path.arc { transition: fill 0.5s ease; }
        .progress-bar-chart .bar { transition: width 1s ease-out; }
        .stacked-bar-chart rect { transition: fill 0.3s ease; }
        .grouped-bar-chart rect { transition: fill 0.3s ease; }
        .candlestick-chart rect { transition: fill 0.3s ease; }
        .waterfall-chart rect { transition: fill 0.3s ease; }
        .chord-diagram path { transition: fill 0.3s ease; }
        .chord-diagram path:hover { filter: brightness(1.2); }
        .sunburst-chart path { transition: fill 0.3s ease; }
        .sunburst-chart path:hover { filter: brightness(1.2); }
        .sankey-diagram rect { fill: #3b82f6; opacity: 0.8; transition: opacity 0.3s ease; }
        .sankey-diagram rect:hover { opacity: 1; }
        .sankey-diagram path { fill: none; stroke: #cbd5e1; stroke-opacity: 0.5; transition: stroke-opacity 0.3s ease; }
        .sankey-diagram path:hover { stroke-opacity: 0.8; }
        .force-directed-graph circle { fill: url(#nodeGradient); stroke: white; stroke-width: 1.5; transition: r 0.2s ease; }
        .force-directed-graph circle:hover { r: 10; stroke-width: 3; }
        .force-directed-graph line { stroke: #94a3b8; stroke-opacity: 0.6; stroke-width: 1; }
        .stacked-area-chart path { transition: opacity 0.3s ease; }
        .radial-bar-chart path { transition: opacity 0.3s ease; }
        .bullet-chart rect, .bullet-chart line { transition: opacity 0.3s ease, width 0.5s ease-out; }
        .box-plot rect, .box-plot line { transition: opacity 0.3s ease; }
        .choropleth-chart rect { transition: opacity 0.3s ease, height 0.5s ease-out; }
        .streamgraph-chart path { transition: opacity 0.3s ease; }
        .tree-chart line, .tree-chart circle { transition: opacity 0.3s ease; }
        .word-cloud-chart text { transition: font-size 0.5s ease-out, opacity 0.3s ease; }
        .parallel-coordinates-chart line { transition: opacity 0.3s ease; }
        .polar-area-chart path { transition: opacity 0.3s ease; }
        .funnel-chart rect { transition: opacity 0.3s ease, width 0.5s ease-out; }
        .pyramid-chart rect { transition: opacity 0.3s ease, width 0.5s ease-out; }
        .bullet-list-chart rect, .bullet-list-chart line { transition: opacity 0.3s ease, width 0.5s ease-out; }
        .calendar-heatmap-chart rect { transition: opacity 0.3s ease; }
        .chord-matrix-chart rect { transition: opacity 0.3s ease; }
        .packed-circles-chart circle { transition: r 0.5s ease-out, opacity 0.3s ease; }
        .density-plot-chart path { transition: stroke-dashoffset 2s ease-in-out; }
        .polar-line-chart path { transition: stroke-dashoffset 2s ease-in-out; }
        .gauge-multi-chart path { transition: fill 0.5s ease; }
        .timeline-chart circle, .timeline-chart text { transition: opacity 0.3s ease; }
        .chord-simple-chart path { transition: opacity 0.3s ease; }

        /* Specific chart styles (Three.js) */
        .three-chart-container {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #f8fafc;
            border-radius: 1rem;
            border: 1px solid #cbd5e1;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
        }
        .dark .three-chart-container {
            background-color: #0f172a;
            border-color: #475569;
        }
        .three-chart-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
    <script>
        // Initialize dark mode preference immediately to prevent FOUC
        if (localStorage.getItem('darkMode') === 'true' ||
            (!('darkMode' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }

        // Function to show a custom message box
        window.showMessageBox = function(message, type, title = 'Notification') {
            const messageBoxOverlay = document.getElementById('messageBoxOverlay');
            const messageBoxTitle = document.getElementById('messageBoxTitle');
            const messageBoxText = document.getElementById('messageBoxText');
            const messageBoxButton = document.getElementById('messageBoxButton');

            messageBoxTitle.textContent = title;
            messageBoxText.textContent = message;

            // Apply type-specific styling
            messageBoxTitle.className = 'text-xl font-bold mb-3';
            messageBoxButton.className = 'message-box-button';

            if (type === 'success') {
                messageBoxTitle.classList.add('text-green-600', 'dark:text-green-400');
                messageBoxButton.classList.add('bg-green-600', 'hover:bg-green-700', 'dark:bg-green-500', 'dark:hover:bg-green-600');
            } else if (type === 'error') {
                messageBoxTitle.classList.add('text-red-600', 'dark:text-red-400');
                messageBoxButton.classList.add('bg-red-600', 'hover:bg-red-700', 'dark:bg-red-500', 'dark:hover:bg-red-600');
            } else { // info or default
                messageBoxTitle.classList.add('text-blue-600', 'dark:text-blue-400');
                messageBoxButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'dark:bg-blue-500', 'dark:hover:bg-blue-600');
            }

            messageBoxOverlay.classList.add('open');
            document.body.style.overflow = 'hidden'; // Prevent scrolling when modal is open
        };

        // Function to close the custom message box
        window.closeMessageBox = function() {
            document.getElementById('messageBoxOverlay').classList.remove('open');
            document.body.style.overflow = ''; // Restore scrolling
        };

        // Function to toggle dark mode
        window.toggleDarkMode = function() {
            const isDarkMode = document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', isDarkMode);
            showMessageBox(`Dark mode ${isDarkMode ? 'enabled' : 'disabled'}!`, 'info', 'Theme Change');
        };

        // Function to toggle code visibility
        window.toggleCode = function(chartId) {
            const codeContainer = document.getElementById(chartId + 'Code');
            if (codeContainer) {
                codeContainer.classList.toggle('open');
                const button = document.querySelector(`#${chartId} .toggle-code-button`);
                if (button) {
                    button.textContent = codeContainer.classList.contains('open') ? 'Hide Code' : 'Show Code';
                }
            }
        };

        // Chart rendering functions (D3.js)
        const chartRenderFunctions = {
            'bar': function(svg, width, height, defs) {
                const barData = [
                    { category: 'A', value: 30 }, { category: 'B', value: 80 },
                    { category: 'C', value: 45 }, { category: 'D', value: 60 },
                    { category: 'E', value: 20 }
                ];
                const xBar = d3.scaleBand().range([0, width]).padding(0.1).domain(barData.map(d => d.category));
                const yBar = d3.scaleLinear().range([height, 0]).domain([0, d3.max(barData, d => d.value)]);
                svg.selectAll(".bar")
                    .data(barData)
                    .enter().append("rect")
                    .attr("class", "bar-chart rect")
                    .attr("x", d => xBar(d.category))
                    .attr("width", xBar.bandwidth())
                    .attr("y", height).attr("height", 0)
                    .transition().duration(800).delay((d, i) => i * 100)
                    .attr("y", d => yBar(d.value)).attr("height", d => height - yBar(d.value));
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xBar));
                svg.append("g").call(d3.axisLeft(yBar));
            },
            'line': function(svg, width, height, defs) {
                const lineData = [
                    { date: new Date("2023-01-01"), value: 50 }, { date: new Date("2023-02-01"), value: 70 },
                    { date: new Date("2023-03-01"), value: 60 }, { date: new Date("2023-04-01"), value: 90 },
                    { date: new Date("2023-05-01"), value: 80 }
                ];
                const xLine = d3.scaleTime().range([0, width]).domain(d3.extent(lineData, d => d.date));
                const yLine = d3.scaleLinear().range([height, 0]).domain([0, d3.max(lineData, d => d.value) + 10]);
                const line = d3.line().x(d => xLine(d.date)).y(d => yLine(d.value));
                svg.append("path")
                    .datum(lineData)
                    .attr("class", "line-chart path")
                    .attr("d", line)
                    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
                svg.selectAll("circle").data(lineData).enter().append("circle")
                    .attr("class", "line-chart circle")
                    .attr("cx", d => xLine(d.date)).attr("cy", d => yLine(d.value)).attr("r", 5)
                    .style("opacity", 0).transition().delay(1800).duration(500).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xLine));
                svg.append("g").call(d3.axisLeft(yLine));
            },
            'pie': function(svg, width, height, defs) {
                const pieData = [{ label: 'Red', value: 30 }, { label: 'Blue', value: 20 }, { label: 'Green', value: 50 }];
                const radius = Math.min(width, height) / 2;
                const pie = d3.pie().value(d => d.value);
                const arc = d3.arc().innerRadius(0).outerRadius(radius);
                const color = d3.scaleOrdinal(d3.schemeCategory10);
                const arcs = svg.attr("transform", `translate(${width / 2},${height / 2})`).selectAll("arc").data(pie(pieData)).enter().append("g").attr("class", "pie-chart arc");
                arcs.append("path").attr("d", arc).attr("fill", (d, i) => color(i)).each(function(d) { this._current = d; });
                arcs.selectAll("path").transition().duration(750).attrTween("d", function(d) { const interpolate = d3.interpolate(this._current, d); this._current = interpolate(0); return function(t) { return arc(interpolate(t)); }; });
                arcs.append("text").attr("transform", d => `translate(${arc.centroid(d)})`).attr("text-anchor", "middle").text(d => d.data.label).style("fill", "white").style("font-size", "12px").style("opacity", 0).transition().delay(750).duration(500).style("opacity", 1);
            },
            'donut': function(svg, width, height, defs) {
                const donutData = [{ label: 'A', value: 40 }, { label: 'B', value: 25 }, { label: 'C', value: 35 }];
                const donutRadius = Math.min(width, height) / 2;
                const innerRadius = donutRadius * 0.6;
                const donutPie = d3.pie().value(d => d.value);
                const donutArc = d3.arc().innerRadius(innerRadius).outerRadius(donutRadius);
                const donutColor = d3.scaleOrdinal(d3.schemeSet2);
                const donutArcs = svg.attr("transform", `translate(${width / 2},${height / 2})`).selectAll("arc").data(donutPie(donutData)).enter().append("g").attr("class", "donut-chart arc");
                donutArcs.append("path").attr("d", donutArc).attr("fill", (d, i) => donutColor(i)).each(function(d) { this._current = d; });
                donutArcs.selectAll("path").transition().duration(750).attrTween("d", function(d) { const interpolate = d3.interpolate(this._current, d); this._current = interpolate(0); return function(t) { return donutArc(interpolate(t)); }; });
                donutArcs.append("text").attr("transform", d => `translate(${donutArc.centroid(d)})`).attr("text-anchor", "middle").text(d => d.data.label).style("fill", "white").style("font-size", "12px").style("opacity", 0).transition().delay(750).duration(500).style("opacity", 1);
            },
            'area': function(svg, width, height, defs) {
                const areaData = [
                    { date: new Date("2023-01-01"), value: 30 }, { date: new Date("2023-02-01"), value: 55 },
                    { date: new Date("2023-03-01"), value: 40 }, { date: new Date("2023-04-01"), value: 75 },
                    { date: new Date("2023-05-01"), value: 60 }
                ];
                const xArea = d3.scaleTime().range([0, width]).domain(d3.extent(areaData, d => d.date));
                const yArea = d3.scaleLinear().range([height, 0]).domain([0, d3.max(areaData, d => d.value) + 10]);
                const area = d3.area().x(d => xArea(d.date)).y0(height).y1(d => yArea(d.value));
                svg.append("path").datum(areaData).attr("class", "area-chart path").attr("d", area).style("opacity", 0).transition().duration(1500).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xArea));
                svg.append("g").call(d3.axisLeft(yArea));
            },
            'scatter': function(svg, width, height, defs) {
                const scatterData = [
                    { x: 10, y: 80, size: 5 }, { x: 20, y: 30, size: 8 },
                    { x: 30, y: 90, size: 6 }, { x: 40, y: 20, size: 10 },
                    { x: 50, y: 70, size: 7 }
                ];
                const xScatter = d3.scaleLinear().range([0, width]).domain([0, 60]);
                const yScatter = d3.scaleLinear().range([height, 0]).domain([0, 100]);
                svg.selectAll(".dot").data(scatterData).enter().append("circle")
                    .attr("class", "scatter-plot circle")
                    .attr("cx", d => xScatter(d.x)).attr("cy", d => yScatter(d.y)).attr("r", 0)
                    .transition().duration(800).delay((d, i) => i * 100).attr("r", d => d.size);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScatter));
                svg.append("g").call(d3.axisLeft(yScatter));
            },
            'bubble': function(svg, width, height, defs) {
                const bubbleData = [
                    { x: 10, y: 80, r: 15, label: 'Item 1' }, { x: 30, y: 30, r: 25, label: 'Item 2' },
                    { x: 50, y: 90, r: 10, label: 'Item 3' }, { x: 70, y: 40, r: 20, label: 'Item 4' },
                    { x: 90, y: 60, r: 18, label: 'Item 5' }
                ];
                const xBubble = d3.scaleLinear().range([0, width]).domain([0, 100]);
                const yBubble = d3.scaleLinear().range([height, 0]).domain([0, 100]);
                svg.selectAll(".bubble").data(bubbleData).enter().append("circle")
                    .attr("class", "bubble-chart circle")
                    .attr("cx", d => xBubble(d.x)).attr("cy", d => yBubble(d.y)).attr("r", 0)
                    .transition().duration(1000).delay((d, i) => i * 150).attr("r", d => d.r);
                svg.selectAll(".bubble-label").data(bubbleData).enter().append("text")
                    .attr("x", d => xBubble(d.x)).attr("y", d => yBubble(d.y)).attr("text-anchor", "middle").attr("alignment-baseline", "middle")
                    .style("font-size", "10px").style("fill", "white").text(d => d.label).style("opacity", 0)
                    .transition().delay(1000).duration(500).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xBubble));
                svg.append("g").call(d3.axisLeft(yBubble));
            },
            'radar': function(svg, width, height, defs) {
                const radarData = [
                    { skill: 'Strength', value: 0.8 }, { skill: 'Intelligence', value: 0.6 },
                    { skill: 'Agility', value: 0.9 }, { skill: 'Stamina', value: 0.7 },
                    { skill: 'Charisma', value: 0.5 }
                ];
                const radarRadius = Math.min(width, height) / 2 - 20;
                const centerX = width / 2;
                const centerY = height / 2;
                const angleSlice = Math.PI * 2 / radarData.length;
                const rScale = d3.scaleLinear().range([0, radarRadius]).domain([0, 1]);
                svg.selectAll(".radar-circle").data([0.2, 0.4, 0.6, 0.8, 1.0]).enter().append("circle")
                    .attr("cx", centerX).attr("cy", centerY).attr("r", d => rScale(d)).style("fill", "none").style("stroke", "#cbd5e1").style("stroke-width", 1);
                const axis = svg.selectAll(".axis").data(radarData).enter().append("g").attr("class", "radar-chart axis");
                axis.append("line")
                    .attr("x1", centerX).attr("y1", centerY)
                    .attr("x2", (d, i) => centerX + rScale(1) * Math.cos(angleSlice * i - Math.PI / 2))
                    .attr("y2", (d, i) => centerY + rScale(1) * Math.sin(angleSlice * i - Math.PI / 2))
                    .attr("class", "radar-chart line");
                axis.append("text")
                    .attr("x", (d, i) => centerX + rScale(1.1) * Math.cos(angleSlice * i - Math.PI / 2))
                    .attr("y", (d, i) => centerY + rScale(1.1) * Math.sin(angleSlice * i - Math.PI / 2))
                    .attr("text-anchor", "middle").style("font-size", "10px").style("fill", "currentColor").text(d => d.skill);
                const radarLine = d3.lineRadial().radius(d => rScale(d.value)).angle((d, i) => i * angleSlice);
                svg.append("path").datum(radarData.concat(radarData[0])).attr("class", "radar-chart area").attr("d", radarLine).attr("transform", `translate(${centerX},${centerY})`).style("opacity", 0).transition().duration(1500).style("opacity", 1);
                svg.append("path").datum(radarData.concat(radarData[0])).attr("class", "radar-chart line").attr("d", radarLine).attr("transform", `translate(${centerX},${centerY})`).attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() }).transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
                svg.selectAll(".radar-point").data(radarData).enter().append("circle")
                    .attr("class", "radar-chart circle")
                    .attr("cx", (d, i) => centerX + rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2))
                    .attr("cy", (d, i) => centerY + rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2))
                    .attr("r", 4).style("opacity", 0).transition().delay(1800).duration(500).style("opacity", 1);
            },
            'heatmap': function(svg, width, height, defs) {
                const heatmapData = [
                    { row: 'A', col: 'X', value: 10 }, { row: 'A', col: 'Y', value: 40 }, { row: 'A', col: 'Z', value: 70 },
                    { row: 'B', col: 'X', value: 20 }, { row: 'B', col: 'Y', value: 50 }, { row: 'B', col: 'Z', value: 80 },
                    { row: 'C', col: 'X', value: 30 }, { row: 'C', col: 'Y', value: 60 }, { row: 'C', col: 'Z', value: 90 }
                ];
                const rows = Array.from(new Set(heatmapData.map(d => d.row)));
                const cols = Array.from(new Set(heatmapData.map(d => d.col)));
                const xHeatmap = d3.scaleBand().range([0, width]).domain(cols).padding(0.05);
                const yHeatmap = d3.scaleBand().range([height, 0]).domain(rows).padding(0.05);
                const colorHeatmap = d3.scaleSequential(d3.interpolateViridis).domain([0, 100]);
                svg.selectAll(".cell").data(heatmapData).enter().append("rect")
                    .attr("class", "heatmap rect")
                    .attr("x", d => xHeatmap(d.col)).attr("y", d => yHeatmap(d.row))
                    .attr("width", xHeatmap.bandwidth()).attr("height", yHeatmap.bandwidth())
                    .attr("fill", d => colorHeatmap(d.value)).style("opacity", 0)
                    .transition().duration(800).delay((d, i) => i * 50).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xHeatmap));
                svg.append("g").call(d3.axisLeft(yHeatmap));
            },
            'treemap': function(svg, width, height, defs) {
                const treemapData = {
                    name: "root",
                    children: [
                        { name: "Category A", size: 100, color: "#3b82f6" },
                        { name: "Category B", size: 60, color: "#10b981" },
                        { name: "Category C", size: 40, color: "#ef4444" },
                        { name: "Category D", size: 20, color: "#f59e0b" }
                    ]
                };
                const treemap = d3.treemap().size([width, height]).padding(1);
                const root = d3.hierarchy(treemapData).sum(d => d.size).sort((a, b) => b.height - a.height || b.value - a.value);
                treemap(root);
                svg.selectAll(".node").data(root.leaves()).enter().append("rect")
                    .attr("class", "treemap rect")
                    .attr("x", d => d.x0).attr("y", d => d.y0)
                    .attr("width", d => d.x1 - d.x0).attr("height", d => d.y1 - d.y0)
                    .attr("fill", d => d.data.color).style("opacity", 0)
                    .transition().duration(1000).delay((d, i) => i * 100).style("opacity", 1);
                svg.selectAll(".node-label").data(root.leaves()).enter().append("text")
                    .attr("x", d => d.x0 + 5).attr("y", d => d.y0 + 20).text(d => d.data.name)
                    .style("font-size", "12px").style("fill", "white").style("opacity", 0)
                    .transition().delay(1000).duration(500).style("opacity", 1);
            },
            'gauge': function(svg, width, height, defs) {
                const gaugeValue = 75;
                const gaugeRadius = Math.min(width, height) / 2 - 20;
                const arcGauge = d3.arc().innerRadius(gaugeRadius * 0.7).outerRadius(gaugeRadius).startAngle(-Math.PI / 2);
                const backgroundArc = arcGauge.endAngle(Math.PI / 2);
                const foregroundArc = arcGauge.endAngle(Math.PI / 2 * (gaugeValue / 100) - Math.PI / 2);
                const gaugeGroup = svg.attr("transform", `translate(${width / 2},${height / 2})`);
                gaugeGroup.append("path").attr("d", backgroundArc).attr("fill", "#e2e8f0");
                gaugeGroup.append("path").attr("class", "gauge-chart arc").attr("d", foregroundArc).attr("fill", "#3b82f6")
                    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(1500).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
                gaugeGroup.append("text").attr("text-anchor", "middle").attr("y", 10).style("font-size", "36px").style("font-weight", "bold").style("fill", "currentColor").text(`${gaugeValue}%`).style("opacity", 0).transition().delay(1500).duration(500).style("opacity", 1);
            },
            'progress': function(svg, width, height, defs) {
                const progressData = [
                    { label: 'Task 1', value: 90, color: '#3b82f6' }, { label: 'Task 2', value: 70, color: '#10b981' },
                    { label: 'Task 3', value: 50, color: '#ef4444' }, { label: 'Task 4', value: 25, color: '#f59e0b' }
                ];
                const barHeight = 20;
                const padding = 10;
                const totalHeight = progressData.length * (barHeight + padding);
                const startY = (height - totalHeight) / 2;
                const xScale = d3.scaleLinear().range([0, width]).domain([0, 100]);
                const progressGroup = svg.append("g").attr("transform", `translate(0,${startY})`);
                progressGroup.selectAll(".background-bar").data(progressData).enter().append("rect")
                    .attr("class", "background-bar").attr("x", 0).attr("y", (d, i) => i * (barHeight + padding))
                    .attr("width", width).attr("height", barHeight).attr("fill", "#e2e8f0");
                progressGroup.selectAll(".progress-bar").data(progressData).enter().append("rect")
                    .attr("class", "progress-bar-chart bar")
                    .attr("x", 0).attr("y", (d, i) => i * (barHeight + padding)).attr("height", barHeight)
                    .attr("fill", d => d.color).attr("width", 0)
                    .transition().duration(1000).delay((d, i) => i * 150).attr("width", d => xScale(d.value));
                progressGroup.selectAll(".progress-label").data(progressData).enter().append("text")
                    .attr("x", 5).attr("y", (d, i) => i * (barHeight + padding) + barHeight / 2 + 5)
                    .text(d => d.label).style("fill", "currentColor").style("font-size", "12px").style("opacity", 0)
                    .transition().delay(1000).duration(500).style("opacity", 1);
                progressGroup.selectAll(".progress-value").data(progressData).enter().append("text")
                    .attr("x", d => xScale(d.value) - 20).attr("y", (d, i) => i * (barHeight + padding) + barHeight / 2 + 5)
                    .text(d => `${d.value}%`).style("fill", "white").style("font-size", "12px").style("opacity", 0)
                    .transition().delay(1000).duration(500).style("opacity", 1);
            },
            'stacked-bar': function(svg, width, height, defs) {
                const stackedData = [
                    { category: 'A', value1: 20, value2: 30, value3: 10 },
                    { category: 'B', value1: 30, value2: 20, value3: 25 },
                    { category: 'C', value1: 15, value2: 40, value3: 30 }
                ];
                const keys = ['value1', 'value2', 'value3'];
                const stackedColors = d3.scaleOrdinal(d3.schemeCategory10);
                const xStacked = d3.scaleBand().range([0, width]).padding(0.1).domain(stackedData.map(d => d.category));
                const yStacked = d3.scaleLinear().range([height, 0]).domain([0, d3.max(stackedData, d => d.value1 + d.value2 + d.value3)]);
                const stack = d3.stack().keys(keys);
                const stackedSeries = stack(stackedData);
                svg.selectAll(".stacked-group").data(stackedSeries).enter().append("g")
                    .attr("fill", d => stackedColors(d.key)).attr("class", "stacked-bar-chart rect")
                    .selectAll("rect").data(d => d).enter().append("rect")
                    .attr("x", d => xStacked(d.data.category)).attr("width", xStacked.bandwidth())
                    .attr("y", height).attr("height", 0)
                    .transition().duration(800).delay((d, i) => i * 100)
                    .attr("y", d => yStacked(d[1])).attr("height", d => yStacked(d[0]) - yStacked(d[1]));
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xStacked));
                svg.append("g").call(d3.axisLeft(yStacked));
            },
            'grouped-bar': function(svg, width, height, defs) {
                const groupedData = [
                    { category: 'A', group1: 20, group2: 30 },
                    { category: 'B', group1: 30, group2: 20 },
                    { category: 'C', group1: 15, group2: 40 }
                ];
                const groupedKeys = ['group1', 'group2'];
                const groupedColors = d3.scaleOrdinal(d3.schemeSet1);
                const xGrouped0 = d3.scaleBand().rangeRound([0, width]).paddingInner(0.1).domain(groupedData.map(d => d.category));
                const xGrouped1 = d3.scaleBand().padding(0.05).domain(groupedKeys).rangeRound([0, xGrouped0.bandwidth()]);
                const yGrouped = d3.scaleLinear().rangeRound([height, 0]).domain([0, d3.max(groupedData, d => d3.max(groupedKeys, key => d[key]))]);
                svg.append("g").selectAll("g").data(groupedData).enter().append("g")
                    .attr("transform", d => `translate(${xGrouped0(d.category)},0)`).attr("class", "grouped-bar-chart rect")
                    .selectAll("rect").data(d => groupedKeys.map(key => ({ key: key, value: d[key] })))
                    .enter().append("rect")
                    .attr("x", d => xGrouped1(d.key)).attr("width", xGrouped1.bandwidth())
                    .attr("fill", d => groupedColors(d.key))
                    .attr("y", height).attr("height", 0)
                    .transition().duration(800).delay((d, i) => i * 100)
                    .attr("y", d => yGrouped(d.value)).attr("height", d => height - yGrouped(d.value));
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xGrouped0));
                svg.append("g").call(d3.axisLeft(yGrouped));
            },
            'candlestick': function(svg, width, height, defs) {
                const candlestickData = [
                    { date: "Day 1", open: 50, close: 60, high: 65, low: 45 },
                    { date: "Day 2", open: 55, close: 45, high: 60, low: 40 },
                    { date: "Day 3", open: 48, close: 58, high: 62, low: 47 },
                    { date: "Day 4", open: 52, close: 50, high: 55, low: 48 }
                ];
                const xCandle = d3.scaleBand().range([0, width]).padding(0.5).domain(candlestickData.map(d => d.date));
                const yCandle = d3.scaleLinear().range([height, 0]).domain([d3.min(candlestickData, d => d.low) - 5, d3.max(candlestickData, d => d.high) + 5]);
                svg.selectAll(".wick").data(candlestickData).enter().append("line")
                    .attr("class", "candlestick-chart line")
                    .attr("x1", d => xCandle(d.date) + xCandle.bandwidth() / 2).attr("x2", d => xCandle(d.date) + xCandle.bandwidth() / 2)
                    .attr("y1", d => yCandle(d.low)).attr("y2", d => yCandle(d.high))
                    .attr("stroke", "currentColor").attr("stroke-width", 1);
                svg.selectAll(".body").data(candlestickData).enter().append("rect")
                    .attr("class", "candlestick-chart rect")
                    .attr("x", d => xCandle(d.date)).attr("y", d => yCandle(Math.max(d.open, d.close)))
                    .attr("width", xCandle.bandwidth()).attr("height", d => Math.abs(yCandle(d.open) - yCandle(d.close)))
                    .attr("fill", d => d.open > d.close ? "#ef4444" : "#10b981").style("opacity", 0)
                    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xCandle));
                svg.append("g").call(d3.axisLeft(yCandle));
            },
            'waterfall': function(svg, width, height, defs) {
                const waterfallData = [
                    { label: "Start", value: 100, type: "start" }, { label: "Increase A", value: 20, type: "increase" },
                    { label: "Decrease B", value: -10, type: "decrease" }, { label: "Increase C", value: 15, type: "increase" },
                    { label: "End", value: 0, type: "end" }
                ];
                let cumulative = 0;
                waterfallData.forEach((d, i) => {
                    if (d.type === "start") { d.start = 0; d.end = d.value; cumulative = d.value; }
                    else if (d.type === "end") { d.start = 0; d.end = cumulative + d.value; }
                    else { d.start = cumulative; d.end = cumulative + d.value; cumulative += d.value; }
                });
                const xWaterfall = d3.scaleBand().range([0, width]).padding(0.2).domain(waterfallData.map(d => d.label));
                const yWaterfall = d3.scaleLinear().range([height, 0]).domain([d3.min(waterfallData, d => Math.min(d.start, d.end)) - 10, d3.max(waterfallData, d => Math.max(d.start, d.end)) + 10]);
                svg.selectAll(".bar").data(waterfallData).enter().append("rect")
                    .attr("class", "waterfall-chart rect")
                    .attr("x", d => xWaterfall(d.label)).attr("width", xWaterfall.bandwidth())
                    .attr("y", d => yWaterfall(Math.max(d.start, d.end))).attr("height", d => Math.abs(yWaterfall(d.start) - yWaterfall(d.end)))
                    .attr("fill", d => { if (d.type === "start" || d.type === "end") return "#3b82f6"; return d.value > 0 ? "#10b981" : "#ef4444"; })
                    .style("opacity", 0).transition().duration(800).delay((d, i) => i * 100).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xWaterfall));
                svg.append("g").call(d3.axisLeft(yWaterfall));
            },
            'stacked-area': function(svg, width, height, defs) {
                const stackedAreaData = [
                    { date: new Date("2023-01-01"), value1: 10, value2: 15, value3: 5 },
                    { date: new Date("2023-02-01"), value1: 12, value2: 18, value3: 7 },
                    { date: new Date("2023-03-01"), value1: 8, value2: 20, value3: 10 },
                    { date: new Date("2023-04-01"), value1: 15, value2: 10, value3: 12 },
                    { date: new Date("2023-05-01"), value1: 18, value2: 12, value3: 8 }
                ];
                const stackedAreaKeys = ['value1', 'value2', 'value3'];
                const stackedAreaColors = d3.scaleOrdinal(d3.schemePastel1);
                const xStackedArea = d3.scaleTime().range([0, width]).domain(d3.extent(stackedAreaData, d => d.date));
                const yStackedArea = d3.scaleLinear().range([height, 0]).domain([0, d3.max(stackedAreaData, d => d.value1 + d.value2 + d.value3)]);
                const stackedArea = d3.area().x(d => xStackedArea(d.data.date)).y0(d => yStackedArea(d[0])).y1(d => yStackedArea(d[1]));
                const stackArea = d3.stack().keys(stackedAreaKeys);
                const stackedAreaSeries = stackArea(stackedAreaData);
                svg.selectAll(".stacked-area").data(stackedAreaSeries).enter().append("path")
                    .attr("class", "stacked-area-chart path").attr("fill", d => stackedAreaColors(d.key)).attr("d", stackedArea)
                    .style("opacity", 0).transition().duration(1500).delay((d, i) => i * 200).style("opacity", 0.8);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xStackedArea));
                svg.append("g").call(d3.axisLeft(yStackedArea));
            },
            'radial-bar': function(svg, width, height, defs) {
                const radialBarData = [
                    { category: 'A', value: 70 }, { category: 'B', value: 50 },
                    { category: 'C', value: 90 }, { category: 'D', value: 60 }
                ];
                const radialRadius = Math.min(width, height) / 2 - 20;
                const radialInnerRadius = 50;
                const xRadial = d3.scaleBand().range([0, 2 * Math.PI]).align(0).domain(radialBarData.map(d => d.category));
                const yRadial = d3.scaleRadial().range([radialInnerRadius, radialRadius]).domain([0, 100]);
                const radialArc = d3.arc().innerRadius(radialInnerRadius).outerRadius(d => yRadial(d.value))
                    .startAngle(d => xRadial(d.category)).endAngle(d => xRadial(d.category) + xRadial.bandwidth())
                    .padAngle(0.01).padRadius(radialInnerRadius);
                const radialColor = d3.scaleOrdinal(d3.schemeSpectral[radialBarData.length]);
                svg.attr("transform", `translate(${width / 2},${height / 2})`).selectAll("path").data(radialBarData).enter().append("path")
                    .attr("class", "radial-bar-chart path").attr("fill", (d, i) => radialColor(i)).attr("d", radialArc)
                    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 150).style("opacity", 1);
            },
            'bullet': function(svg, width, height, defs) {
                const bulletData = {
                    title: "Revenue", subtitle: "USD",
                    ranges: [150, 225, 300], measures: [270], markers: [250]
                };
                const xBullet = d3.scaleLinear().range([0, width]).domain([0, d3.max(bulletData.ranges)]);
                const bulletHeight = 30;
                const bulletY = (height - bulletHeight) / 2;
                svg.selectAll("rect.range").data(bulletData.ranges).enter().append("rect")
                    .attr("class", "bullet-chart range").attr("height", bulletHeight).attr("x", 0).attr("y", bulletY)
                    .attr("width", d => xBullet(d)).attr("fill", (d, i) => ["#ef4444", "#f59e0b", "#10b981"][i])
                    .style("opacity", 0).transition().duration(800).delay((d, i) => i * 100).style("opacity", 0.6);
                svg.selectAll("rect.measure").data(bulletData.measures).enter().append("rect")
                    .attr("class", "bullet-chart measure").attr("height", bulletHeight / 2).attr("x", 0).attr("y", bulletY + bulletHeight / 4)
                    .attr("width", 0).attr("fill", "#3b82f6").transition().duration(1200).attr("width", d => xBullet(d));
                svg.selectAll("line.marker").data(bulletData.markers).enter().append("line")
                    .attr("class", "bullet-chart marker")
                    .attr("x1", d => xBullet(d)).attr("x2", d => xBullet(d)).attr("y1", bulletY - 5).attr("y2", bulletY + bulletHeight + 5)
                    .attr("stroke", "black").attr("stroke-width", 2).style("opacity", 0)
                    .transition().delay(1200).duration(500).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${bulletY + bulletHeight})`).call(d3.axisBottom(xBullet));
            },
            'box-plot': function(svg, width, height, defs) {
                const boxData = [
                    { category: "Group 1", min: 10, q1: 20, median: 30, q3: 40, max: 50 },
                    { category: "Group 2", min: 15, q1: 25, median: 35, q3: 45, max: 55 }
                ];
                const xBox = d3.scaleBand().range([0, width]).padding(0.5).domain(boxData.map(d => d.category));
                const yBox = d3.scaleLinear().range([height, 0]).domain([0, 60]);
                const boxWidth = xBox.bandwidth() * 0.7;
                const boxes = svg.selectAll(".box-group").data(boxData).enter().append("g")
                    .attr("transform", d => `translate(${xBox(d.category) + (xBox.bandwidth() - boxWidth) / 2},0)`);
                boxes.append("rect").attr("class", "box-plot box").attr("x", 0).attr("y", d => yBox(d.q3))
                    .attr("width", boxWidth).attr("height", d => yBox(d.q1) - yBox(d.q3))
                    .attr("fill", "#3b82f6").style("opacity", 0).transition().duration(800).delay((d, i) => i * 100).style("opacity", 0.7);
                boxes.append("line").attr("class", "box-plot median").attr("x1", 0).attr("x2", boxWidth)
                    .attr("y1", d => yBox(d.median)).attr("y2", d => yBox(d.median))
                    .attr("stroke", "white").attr("stroke-width", 2).style("opacity", 0)
                    .transition().delay(800).duration(500).style("opacity", 1);
                boxes.append("line").attr("class", "box-plot whisker").attr("x1", boxWidth / 2).attr("x2", boxWidth / 2)
                    .attr("y1", d => yBox(d.min)).attr("y2", d => yBox(d.q1)).attr("stroke", "currentColor").attr("stroke-width", 1);
                boxes.append("line").attr("class", "box-plot whisker").attr("x1", boxWidth / 2).attr("x2", boxWidth / 2)
                    .attr("y1", d => yBox(d.q3)).attr("y2", d => yBox(d.max)).attr("stroke", "currentColor").attr("stroke-width", 1);
                boxes.append("line").attr("class", "box-plot cap").attr("x1", boxWidth * 0.2).attr("x2", boxWidth * 0.8)
                    .attr("y1", d => yBox(d.min)).attr("y2", d => yBox(d.min)).attr("stroke", "currentColor").attr("stroke-width", 1);
                boxes.append("line").attr("class", "box-plot cap").attr("x1", boxWidth * 0.2).attr("x2", boxWidth * 0.8)
                    .attr("y1", d => yBox(d.max)).attr("y2", d => yBox(d.max)).attr("stroke", "currentColor").attr("stroke-width", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xBox));
                svg.append("g").call(d3.axisLeft(yBox));
            },
            'choropleth': function(svg, width, height, defs) {
                const choroplethData = [
                    { region: "North", value: 80, color: "#a7f3d0" }, { region: "East", value: 50, color: "#6ee7b7" },
                    { region: "South", value: 90, color: "#34d399" }, { region: "West", value: 30, color: "#10b981" }
                ];
                const xChoropleth = d3.scaleBand().range([0, width]).padding(0.1).domain(choroplethData.map(d => d.region));
                const yChoropleth = d3.scaleLinear().range([height, 0]).domain([0, 100]);
                svg.selectAll(".region").data(choroplethData).enter().append("rect")
                    .attr("class", "choropleth-chart rect")
                    .attr("x", d => xChoropleth(d.region)).attr("y", height).attr("width", xChoropleth.bandwidth()).attr("height", 0)
                    .attr("fill", d => d.color).transition().duration(800).delay((d, i) => i * 100)
                    .attr("y", d => yChoropleth(d.value)).attr("height", d => height - yChoropleth(d.value));
                svg.selectAll(".region-label").data(choroplethData).enter().append("text")
                    .attr("x", d => xChoropleth(d.region) + xChoropleth.bandwidth() / 2).attr("y", d => yChoropleth(d.value) - 5)
                    .attr("text-anchor", "middle").text(d => `${d.region}: ${d.value}`).style("font-size", "12px").style("fill", "currentColor").style("opacity", 0)
                    .transition().delay(800).duration(500).style("opacity", 1);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xChoropleth));
                svg.append("g").call(d3.axisLeft(yChoropleth));
            },
            'streamgraph': function(svg, width, height, defs) {
                const streamData = [
                    { year: new Date("2020"), a: 20, b: 10, c: 5 }, { year: new Date("2021"), a: 25, b: 12, c: 7 },
                    { year: new Date("2022"), a: 18, b: 15, c: 10 }, { year: new Date("2023"), a: 30, b: 8, c: 12 }
                ];
                const streamKeys = ['a', 'b', 'c'];
                const streamColors = d3.scaleOrdinal(d3.schemeCategory10);
                const xStream = d3.scaleTime().range([0, width]).domain(d3.extent(streamData, d => d.year));
                const yStream = d3.scaleLinear().range([height, 0]);
                const stackStream = d3.stack().keys(streamKeys).offset(d3.stackOffsetWiggle);
                const streamSeries = stackStream(streamData);
                yStream.domain([d3.min(streamSeries, layer => d3.min(layer, d => d[0])), d3.max(streamSeries, layer => d3.max(layer, d => d[1]))]);
                const areaStream = d3.area().x(d => xStream(d.data.year)).y0(d => yStream(d[0])).y1(d => yStream(d[1])).curve(d3.curveBasis);
                svg.selectAll(".stream").data(streamSeries).enter().append("path")
                    .attr("class", "streamgraph-chart path").attr("fill", d => streamColors(d.key)).attr("d", areaStream)
                    .style("opacity", 0).transition().duration(1500).delay((d, i) => i * 200).style("opacity", 0.7);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xStream));
                svg.append("g").call(d3.axisLeft(yStream));
            },
            'tree': function(svg, width, height, defs) {
                const treeData = {
                    name: "Root",
                    children: [
                        { name: "Branch A", children: [{ name: "Leaf A.1" }, { name: "Leaf A.2" }] },
                        { name: "Branch B", children: [{ name: "Leaf B.1" }] }
                    ]
                };
                const treeLayout = d3.tree().size([height, width - 100]);
                const rootTree = d3.hierarchy(treeData);
                treeLayout(rootTree);
                svg.selectAll(".link").data(rootTree.links()).enter().append("path")
                    .attr("class", "tree-chart link").attr("fill", "none").attr("stroke", "#94a3b8").attr("stroke-opacity", 0.6).attr("stroke-width", 1)
                    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
                    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(1500).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
                const nodes = svg.selectAll(".node").data(rootTree.descendants()).enter().append("g")
                    .attr("class", "tree-chart node").attr("transform", d => `translate(${d.y},${d.x})`)
                    .style("opacity", 0).transition().delay(1000).duration(500).style("opacity", 1);
                nodes.append("circle").attr("r", 5).attr("fill", "#3b82f6").attr("stroke", "white").attr("stroke-width", 1.5);
                nodes.append("text").attr("dy", "0.31em").attr("x", d => d.children ? -9 : 9)
                    .attr("text-anchor", d => d.children ? "end" : "start").text(d => d.data.name)
                    .style("font-size", "12px").style("fill", "currentColor");
            },
            'word-cloud': function(svg, width, height, defs) {
                const words = [
                    { text: "Data", size: 40 }, { text: "Visualization", size: 35 },
                    { text: "Charts", size: 30 }, { text: "Analytics", size: 28 },
                    { text: "Trends", size: 25 }, { text: "Insights", size: 22 },
                    { text: "Information", size: 20 }, { text: "Reports", size: 18 },
                    { text: "Metrics", size: 15 }, { text: "Dashboard", size: 13 }
                ];
                const wordColor = d3.scaleOrdinal(d3.schemePaired);
                svg.selectAll("text").data(words).enter().append("text")
                    .attr("class", "word-cloud-chart text").attr("x", () => Math.random() * width).attr("y", () => Math.random() * height)
                    .attr("text-anchor", "middle").style("font-size", 0).style("fill", (d, i) => wordColor(i)).text(d => d.text)
                    .transition().duration(1000).delay((d, i) => i * 100).style("font-size", d => `${d.size}px`);
            },
            'parallel-coordinates': function(svg, width, height, defs) {
                const pcData = [
                    { A: 10, B: 50, C: 20, D: 80 }, { A: 30, B: 20, C: 60, D: 40 }, { A: 50, B: 80, C: 30, D: 60 }
                ];
                const pcDimensions = ['A', 'B', 'C', 'D'];
                const pcColors = d3.scaleOrdinal(d3.schemeCategory10);
                const yPc = {};
                pcDimensions.forEach(dim => { yPc[dim] = d3.scaleLinear().domain([0, 100]).range([height, 0]); });
                const xPc = d3.scalePoint().range([0, width]).padding(1).domain(pcDimensions);
                svg.selectAll(".dimension").data(pcDimensions).enter().append("g")
                    .attr("class", "parallel-coordinates-chart axis").attr("transform", d => `translate(${xPc(d)},0)`)
                    .each(function(d) { d3.select(this).call(d3.axisLeft(yPc[d])); }).append("text")
                    .style("text-anchor", "middle").attr("y", -9).text(d => d).style("fill", "currentColor");
                const pathPc = function(d) { return d3.line()(pcDimensions.map(p => [xPc(p), yPc[p](d[p])])); };
                svg.selectAll(".line").data(pcData).enter().append("path")
                    .attr("class", "parallel-coordinates-chart line").attr("d", pathPc).attr("fill", "none")
                    .attr("stroke", (d, i) => pcColors(i)).attr("stroke-width", 2).style("opacity", 0.7)
                    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(1500).delay((d, i) => i * 200).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
            },
            'polar-area': function(svg, width, height, defs) {
                const polarData = [
                    { label: 'Energy', value: 70 }, { label: 'Focus', value: 50 },
                    { label: 'Mood', value: 90 }, { label: 'Productivity', value: 60 }
                ];
                const polarRadius = Math.min(width, height) / 2 - 20;
                const polarAngle = d3.scaleBand().range([0, 2 * Math.PI]).align(0).domain(polarData.map(d => d.label));
                const polarRadiusScale = d3.scaleLinear().range([0, polarRadius]).domain([0, 100]);
                const polarArc = d3.arc().innerRadius(0).outerRadius(d => polarRadiusScale(d.data.value))
                    .startAngle(d => polarAngle(d.data.label)).endAngle(d => polarAngle(d.data.label) + polarAngle.bandwidth())
                    .padAngle(0.01);
                const polarColor = d3.scaleOrdinal(d3.schemeSet3);
                const polarGroup = svg.attr("transform", `translate(${width / 2},${height / 2})`);
                polarGroup.selectAll("path").data(d3.pie().value(d => d.value).sort(null)(polarData)).enter().append("path")
                    .attr("class", "polar-area-chart path").attr("fill", (d, i) => polarColor(i)).attr("d", polarArc)
                    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 150).style("opacity", 0.8);
                polarGroup.selectAll("text").data(d3.pie().value(d => d.value).sort(null)(polarData)).enter().append("text")
                    .attr("transform", d => `translate(${polarArc.centroid(d)})`).attr("text-anchor", "middle").text(d => d.data.label)
                    .style("font-size", "12px").style("fill", "white").style("opacity", 0)
                    .transition().delay(1000).duration(500).style("opacity", 1);
            },
            'funnel': function(svg, width, height, defs) {
                const funnelData = [
                    { stage: "Awareness", value: 100 }, { stage: "Interest", value: 80 },
                    { stage: "Consideration", value: 60 }, { stage: "Purchase", value: 40 }
                ];
                const funnelMax = d3.max(funnelData, d => d.value);
                const yFunnel = d3.scaleBand().range([0, height]).padding(0.1).domain(funnelData.map(d => d.stage));
                const xFunnel = d3.scaleLinear().range([0, width]).domain([0, funnelMax]);
                const funnelColors = d3.scaleSequential(d3.interpolateBlues).domain([0, funnelData.length]);
                svg.selectAll(".funnel-rect").data(funnelData).enter().append("rect")
                    .attr("class", "funnel-chart rect")
                    .attr("x", d => (width - xFunnel(d.value)) / 2).attr("y", d => yFunnel(d.stage))
                    .attr("width", d => xFunnel(d.value)).attr("height", yFunnel.bandwidth())
                    .attr("fill", (d, i) => funnelColors(i)).style("opacity", 0)
                    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 0.8);
                svg.selectAll(".funnel-label").data(funnelData).enter().append("text")
                    .attr("x", width / 2).attr("y", d => yFunnel(d.stage) + yFunnel.bandwidth() / 2 + 5)
                    .attr("text-anchor", "middle").text(d => `${d.stage} (${d.value})`).style("fill", "white").style("font-size", "14px").style("opacity", 0)
                    .transition().delay(800).duration(500).style("opacity", 1);
            },
            'pyramid': function(svg, width, height, defs) {
                const pyramidData = [
                    { age: "0-14", male: 10, female: 12 }, { age: "15-44", male: 25, female: 28 },
                    { age: "45-64", male: 18, female: 20 }, { age: "65+", male: 8, female: 10 }
                ];
                const xPyramid = d3.scaleLinear().range([0, width]).domain([-d3.max(pyramidData, d => Math.max(d.male, d.female)), d3.max(pyramidData, d => Math.max(d.male, d.female))]);
                const yPyramid = d3.scaleBand().range([height, 0]).padding(0.1).domain(pyramidData.map(d => d.age));
                svg.selectAll(".bar-male").data(pyramidData).enter().append("rect")
                    .attr("class", "pyramid-chart rect")
                    .attr("x", d => xPyramid(0) - xPyramid(d.male)).attr("y", d => yPyramid(d.age))
                    .attr("width", 0).attr("height", yPyramid.bandwidth()).attr("fill", "#3b82f6")
                    .transition().duration(800).delay((d, i) => i * 100).attr("width", d => xPyramid(d.male) - xPyramid(0));
                svg.selectAll(".bar-female").data(pyramidData).enter().append("rect")
                    .attr("class", "pyramid-chart rect")
                    .attr("x", xPyramid(0)).attr("y", d => yPyramid(d.age))
                    .attr("width", 0).attr("height", yPyramid.bandwidth()).attr("fill", "#ef4444")
                    .transition().duration(800).delay((d, i) => i * 100).attr("width", d => xPyramid(d.female) - xPyramid(0));
                svg.append("g").attr("transform", `translate(${xPyramid(0)},0)`).call(d3.axisLeft(yPyramid));
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xPyramid));
            },
            'bullet-list': function(svg, width, height, defs) {
                const bulletListData = [
                    { title: "Sales", subtitle: "kUSD", ranges: [150, 225, 300], measures: [270], markers: [250] },
                    { title: "Profit", subtitle: "%", ranges: [20, 30, 40], measures: [35], markers: [32] },
                    { title: "Customers", subtitle: "count", ranges: [500, 750, 1000], measures: [800], markers: [700] }
                ];
                const bulletListHeight = 50;
                const bulletListPadding = 10;
                bulletListData.forEach((data, i) => {
                    const bulletGroup = svg.append("g").attr("transform", `translate(0,${i * (bulletListHeight + bulletListPadding)})`);
                    const xBulletList = d3.scaleLinear().range([0, width]).domain([0, d3.max(data.ranges)]);
                    bulletGroup.selectAll("rect.range").data(data.ranges).enter().append("rect")
                        .attr("class", "bullet-list-chart range").attr("height", bulletListHeight).attr("x", 0).attr("y", 0)
                        .attr("width", d => xBulletList(d)).attr("fill", (d, idx) => ["#ef4444", "#f59e0b", "#10b981"][idx])
                        .style("opacity", 0).transition().duration(800).delay((idx) => i * 200 + idx * 100).style("opacity", 0.6);
                    bulletGroup.selectAll("rect.measure").data(data.measures).enter().append("rect")
                        .attr("class", "bullet-list-chart measure").attr("height", bulletListHeight / 2).attr("x", 0).attr("y", bulletListHeight / 4)
                        .attr("width", 0).attr("fill", "#3b82f6").transition().duration(1200).delay((idx) => i * 200).attr("width", d => xBulletList(d));
                    bulletGroup.selectAll("line.marker").data(data.markers).enter().append("line")
                        .attr("class", "bullet-list-chart marker")
                        .attr("x1", d => xBulletList(d)).attr("x2", d => xBulletList(d)).attr("y1", -5).attr("y2", bulletListHeight + 5)
                        .attr("stroke", "black").attr("stroke-width", 2).style("opacity", 0)
                        .transition().delay(1200 + i * 200).duration(500).style("opacity", 1);
                    bulletGroup.append("text").attr("x", -40).attr("y", bulletListHeight / 2).attr("dy", "0.35em").attr("text-anchor", "start")
                        .style("font-size", "14px").style("font-weight", "bold").style("fill", "currentColor").text(data.title)
                        .style("opacity", 0).transition().delay(1200 + i * 200).duration(500).style("opacity", 1);
                    bulletGroup.append("text").attr("x", -40).attr("y", bulletListHeight / 2 + 15).attr("dy", "0.35em").attr("text-anchor", "start")
                        .style("font-size", "10px").style("fill", "currentColor").text(data.subtitle)
                        .style("opacity", 0).transition().delay(1200 + i * 200).duration(500).style("opacity", 1);
                });
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xBulletList));
            },
            'calendar-heatmap': function(svg, width, height, defs) {
                const calendarData = Array.from({ length: 365 }, (_, i) => ({
                    date: new Date(2024, 0, i + 1), value: Math.floor(Math.random() * 100)
                }));
                const cellSize = 15;
                const weekDay = d => d.getDay();
                const weekOfYear = d => d3.timeWeek.count(d3.timeYear(d), d);
                const colorCalendar = d3.scaleSequential(d3.interpolateGreens).domain([0, 100]);
                svg.attr("transform", `translate(20,20)`);
                svg.selectAll(".day").data(calendarData).enter().append("rect")
                    .attr("class", "calendar-heatmap-chart rect").attr("width", cellSize).attr("height", cellSize)
                    .attr("x", d => weekOfYear(d.date) * cellSize).attr("y", d => weekDay(d.date) * cellSize)
                    .attr("fill", d => colorCalendar(d.value)).style("opacity", 0)
                    .transition().duration(500).delay((d, i) => i * 5).style("opacity", 1);
                const months = d3.timeMonth.every(1).range(new Date(2024, 0, 1), new Date(2025, 0, 1));
                svg.selectAll(".month-label").data(months).enter().append("text")
                    .attr("x", d => weekOfYear(d) * cellSize).attr("y", -5).text(d3.timeFormat("%b"))
                    .style("font-size", "10px").style("fill", "currentColor");
                const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                svg.selectAll(".weekday-label").data(weekdays).enter().append("text")
                    .attr("x", -5).attr("y", (d, i) => i * cellSize + cellSize / 2).attr("text-anchor", "end").attr("alignment-baseline", "middle")
                    .text(d => d).style("font-size", "10px").style("fill", "currentColor");
            },
            'chord-matrix': function(svg, width, height, defs) {
                const matrixData = [
                    [0, 10, 20], [15, 0, 5], [8, 25, 0]
                ];
                const matrixLabels = ["A", "B", "C"];
                const xMatrix = d3.scaleBand().range([0, width]).padding(0.05).domain(matrixLabels);
                const yMatrix = d3.scaleBand().range([0, height]).padding(0.05).domain(matrixLabels);
                const colorMatrix = d3.scaleSequential(d3.interpolatePurples).domain([0, d3.max(matrixData.flat())]);
                matrixData.forEach((row, i) => {
                    row.forEach((value, j) => {
                        svg.append("rect").attr("class", "chord-matrix-chart rect")
                            .attr("x", xMatrix(matrixLabels[j])).attr("y", yMatrix(matrixLabels[i]))
                            .attr("width", xMatrix.bandwidth()).attr("height", yMatrix.bandwidth())
                            .attr("fill", colorMatrix(value)).style("opacity", 0)
                            .transition().duration(800).delay((i * matrixData[0].length + j) * 50).style("opacity", 1);
                        svg.append("text")
                            .attr("x", xMatrix(matrixLabels[j]) + xMatrix.bandwidth() / 2).attr("y", yMatrix(matrixLabels[i]) + yMatrix.bandwidth() / 2 + 5)
                            .attr("text-anchor", "middle").style("fill", "white").style("font-size", "12px").text(value > 0 ? value : "")
                            .style("opacity", 0).transition().delay(800 + (i * matrixData[0].length + j) * 50).duration(300).style("opacity", 1);
                    });
                });
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xMatrix));
                svg.append("g").call(d3.axisLeft(yMatrix));
            },
            'packed-circles': function(svg, width, height, defs) {
                const packedData = {
                    name: "Root",
                    children: [
                        { name: "Group 1", value: 50 }, { name: "Group 2", value: 30 },
                        { name: "Group 3", value: 20, children: [{ name: "Sub 3.1", value: 12 }, { name: "Sub 3.2", value: 8 }] }
                    ]
                };
                const pack = d3.pack().size([width, height]).padding(2);
                const rootPacked = d3.hierarchy(packedData).sum(d => d.value).sort((a, b) => b.value - a.value);
                const nodesPacked = pack(rootPacked).descendants();
                const packedColor = d3.scaleSequential(d3.interpolateMagma).domain([0, d3.max(nodesPacked, d => d.depth)]);
                svg.selectAll("circle").data(nodesPacked).enter().append("circle")
                    .attr("class", "packed-circles-chart circle")
                    .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", 0)
                    .attr("fill", d => packedColor(d.depth)).style("opacity", 0.8)
                    .transition().duration(800).delay((d, i) => i * 50).attr("r", d => d.r);
                svg.selectAll("text").data(nodesPacked.filter(d => d.depth > 0 && d.r > 10)).enter().append("text")
                    .attr("x", d => d.x).attr("y", d => d.y).attr("text-anchor", "middle").attr("alignment-baseline", "middle")
                    .style("font-size", "10px").style("fill", "white").text(d => d.data.name)
                    .style("opacity", 0).transition().delay(800).duration(500).style("opacity", 1);
            },
            'density-plot': function(svg, width, height, defs) {
                const densityData = Array.from({ length: 100 }, () => Math.random() * 100);
                const xDensity = d3.scaleLinear().range([0, width]).domain([0, 100]);
                const histogram = d3.histogram().value(d => d).domain(xDensity.domain()).thresholds(xDensity.ticks(40));
                const bins = histogram(densityData);
                const yDensity = d3.scaleLinear().range([height, 0]).domain([0, d3.max(bins, d => d.length)]);
                const densityLine = d3.line().curve(d3.curveBasis).x(d => xDensity(d.x0 + (d.x1 - d.x0) / 2)).y(d => yDensity(d.length));
                svg.append("path").datum(bins).attr("class", "density-plot-chart path").attr("fill", "none")
                    .attr("stroke", "#3b82f6").attr("stroke-width", 3).attr("d", densityLine)
                    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xDensity));
                svg.append("g").call(d3.axisLeft(yDensity));
            },
            'polar-line': function(svg, width, height, defs) {
                const polarLineData = [
                    { angle: 0, value: 50 }, { angle: 60, value: 70 }, { angle: 120, value: 60 },
                    { angle: 180, value: 90 }, { angle: 240, value: 80 }, { angle: 300, value: 65 },
                    { angle: 360, value: 50 }
                ];
                const polarLineRadius = Math.min(width, height) / 2 - 20;
                const polarLineAngleScale = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 360]);
                const polarLineRadiusScale = d3.scaleLinear().range([0, polarLineRadius]).domain([0, 100]);
                const polarLine = d3.lineRadial().radius(d => polarLineRadiusScale(d.value)).angle(d => polarLineAngleScale(d.angle)).curve(d3.curveCardinalClosed);
                const polarLineGroup = svg.attr("transform", `translate(${width / 2},${height / 2})`);
                polarLineGroup.append("path").datum(polarLineData).attr("class", "polar-line-chart path").attr("fill", "none")
                    .attr("stroke", "#ef4444").attr("stroke-width", 3).attr("d", polarLine)
                    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
                polarLineGroup.selectAll(".grid-line").data(d3.range(0, 101, 25)).enter().append("circle")
                    .attr("r", d => polarLineRadiusScale(d)).attr("fill", "none").attr("stroke", "#e2e8f0").attr("stroke-dasharray", "2,2");
                polarLineGroup.selectAll(".radial-axis").data(d3.range(0, 360, 30)).enter().append("line")
                    .attr("x1", 0).attr("y1", 0).attr("x2", d => polarLineRadius * Math.cos(polarLineAngleScale(d) - Math.PI / 2))
                    .attr("y2", d => polarLineRadius * Math.sin(polarLineAngleScale(d) - Math.PI / 2)).attr("stroke", "#e2e8f0").attr("stroke-dasharray", "2,2");
            },
            'gauge-multi': function(svg, width, height, defs) {
                const gaugeMultiData = [
                    { value: 40, label: "Low", color: "#ef4444" },
                    { value: 30, label: "Medium", color: "#f59e0b" },
                    { value: 20, label: "High", color: "#10b981" }
                ];
                const gaugeMultiCurrentValue = 75;
                const gaugeMultiRadius = Math.min(width, height) / 2 - 20;
                const gaugeMultiInnerRadius = gaugeMultiRadius * 0.7;
                const gaugeMultiGroup = svg.attr("transform", `translate(${width / 2},${height / 2}) rotate(-90)`);
                let currentAngle = 0;
                gaugeMultiData.forEach((d, i) => {
                    const startAngle = currentAngle;
                    const endAngle = currentAngle + (d.value / 100) * Math.PI;
                    gaugeMultiGroup.append("path")
                        .attr("d", d3.arc().innerRadius(gaugeMultiInnerRadius).outerRadius(gaugeMultiRadius).startAngle(startAngle).endAngle(startAngle))
                        .attr("fill", d.color)
                        .transition().duration(800).delay(i * 200)
                        .attrTween("d", function(t) {
                            const interpolate = d3.interpolate(startAngle, endAngle);
                            return function(t) { return d3.arc().innerRadius(gaugeMultiInnerRadius).outerRadius(gaugeMultiRadius).startAngle(startAngle).endAngle(interpolate(t))(); };
                        });
                    currentAngle = endAngle;
                });
                const pointerLength = gaugeMultiRadius * 0.6;
                const pointerWidth = 8;
                const pointerAngle = (gaugeMultiCurrentValue / 100) * Math.PI;
                gaugeMultiGroup.append("path")
                    .attr("d", d3.arc().innerRadius(0).outerRadius(pointerLength).startAngle(pointerAngle - (pointerWidth / gaugeMultiRadius / 2)).endAngle(pointerAngle + (pointerWidth / gaugeMultiRadius / 2)))
                    .attr("fill", "black").attr("transform", `rotate(0)`)
                    .transition().duration(1500).ease(d3.easeElastic).attr("transform", `rotate(${pointerAngle * 180 / Math.PI})`);
                gaugeMultiGroup.append("circle").attr("r", pointerWidth * 1.5).attr("fill", "black").style("opacity", 0)
                    .transition().delay(1500).duration(300).style("opacity", 1);
                svg.append("text").attr("x", width / 2).attr("y", height / 2 + 50).attr("text-anchor", "middle")
                    .style("font-size", "24px").style("font-weight", "bold").style("fill", "currentColor").text(`${gaugeMultiCurrentValue}%`).style("opacity", 0)
                    .transition().delay(1500).duration(500).style("opacity", 1);
            },
            'timeline': function(svg, width, height, defs) {
                const timelineData = [
                    { date: new Date("2023-01-15"), event: "Project Start" },
                    { date: new Date("2023-03-10"), event: "Milestone 1" },
                    { date: new Date("2023-05-20"), event: "Feature Launch" },
                    { date: new Date("2023-07-01"), event: "Milestone 2" },
                    { date: new Date("2023-09-10"), event: "Project End" }
                ];
                const xTimeline = d3.scaleTime().range([0, width]).domain(d3.extent(timelineData, d => d.date));
                const yTimeline = height / 2;
                svg.append("line").attr("class", "timeline-chart line").attr("x1", 0).attr("x2", width).attr("y1", yTimeline).attr("y2", yTimeline).attr("stroke", "#cbd5e1").attr("stroke-width", 2);
                svg.selectAll(".event-circle").data(timelineData).enter().append("circle")
                    .attr("class", "timeline-chart circle").attr("cx", d => xTimeline(d.date)).attr("cy", yTimeline).attr("r", 0)
                    .attr("fill", "#3b82f6").attr("stroke", "white").attr("stroke-width", 2)
                    .transition().duration(800).delay((d, i) => i * 150).attr("r", 8);
                svg.selectAll(".event-label").data(timelineData).enter().append("text")
                    .attr("x", d => xTimeline(d.date)).attr("y", yTimeline - 20).attr("text-anchor", "middle").text(d => d.event)
                    .style("font-size", "12px").style("fill", "currentColor").style("opacity", 0)
                    .transition().delay(800).duration(500).style("opacity", 1);
                svg.selectAll(".event-date").data(timelineData).enter().append("text")
                    .attr("x", d => xTimeline(d.date)).attr("y", yTimeline + 20).attr("text-anchor", "middle").text(d => d3.timeFormat("%b %d")(d.date))
                    .style("font-size", "10px").style("fill", "#64748b").style("opacity", 0)
                    .transition().delay(800).duration(500).style("opacity", 1);
            },
            'chord-simple': function(svg, width, height, defs) {
                const simpleChordData = [[0, 15, 20], [10, 0, 5], [8, 12, 0]];
                const simpleChordNames = ["Alice", "Bob", "Charlie"];
                const chordLayout = d3.chord().padAngle(0.05).sortSubgroups(d3.descending)(simpleChordData);
                const chordArcSimple = d3.arc().innerRadius(Math.min(width, height) / 2 - 50).outerRadius(Math.min(width, height) / 2 - 30);
                const ribbon = d3.ribbon().radius(Math.min(width, height) / 2 - 50);
                const simpleChordColor = d3.scaleOrdinal(d3.schemeCategory10);
                const simpleChordGroup = svg.attr("transform", `translate(${width / 2},${height / 2})`);
                simpleChordGroup.selectAll("g.arc").data(chordLayout.groups).enter().append("g").append("path")
                    .attr("class", "chord-simple-chart arc").attr("fill", d => simpleChordColor(d.index)).attr("d", chordArcSimple)
                    .style("opacity", 0).transition().duration(800).delay((d, i) => i * 100).style("opacity", 1);
                simpleChordGroup.selectAll("path.ribbon").data(chordLayout).enter().append("path")
                    .attr("class", "chord-simple-chart ribbon").attr("d", ribbon)
                    .attr("fill", d => simpleChordColor(d.source.index)).attr("stroke", d => d3.rgb(simpleChordColor(d.source.index)).darker())
                    .attr("stroke-width", 1).style("opacity", 0).transition().duration(1200).delay((d, i) => i * 150).style("opacity", 0.7);
                simpleChordGroup.selectAll("text").data(chordLayout.groups).enter().append("text")
                    .each(d => { d.outerRadius = Math.min(width, height) / 2 - 20; })
                    .attr("transform", d => `rotate(${(d.startAngle + d.endAngle) / 2 * 180 / Math.PI - 90})translate(${d.outerRadius + 10},0)${(d.startAngle + d.endAngle) / 2 > Math.PI ? "rotate(180)" : ""}`)
                    .attr("text-anchor", d => (d.startAngle + d.endAngle) / 2 > Math.PI ? "end" : "start").text(d => simpleChordNames[d.index])
                    .style("font-size", "12px").style("fill", "currentColor").style("opacity", 0)
                    .transition().delay(1200).duration(500).style("opacity", 1);
            },
            'chord': function(svg, width, height, defs) {
                const chordData = [
                    { name: "Node 1", value: 30, color: "#3b82f6" },
                    { name: "Node 2", value: 20, color: "#10b981" },
                    { name: "Node 3", value: 50, color: "#ef4444" }
                ];
                const chordRadius = Math.min(width, height) / 2 - 20;
                const pieChord = d3.pie().value(d => d.value).sort(null);
                const arcChord = d3.arc().innerRadius(chordRadius * 0.8).outerRadius(chordRadius);
                const colorChord = d3.scaleOrdinal(d3.schemeCategory10);
                const chordGroup = svg.attr("transform", `translate(${width / 2},${height / 2})`);
                chordGroup.selectAll(".arc").data(pieChord(chordData)).enter().append("path")
                    .attr("class", "chord-diagram path").attr("d", arcChord).attr("fill", (d, i) => colorChord(i))
                    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 150).style("opacity", 1);
                chordGroup.selectAll(".label").data(pieChord(chordData)).enter().append("text")
                    .attr("transform", d => `translate(${arcChord.centroid(d)})`).attr("text-anchor", "middle").text(d => d.data.name)
                    .style("font-size", "12px").style("fill", "white").style("opacity", 0)
                    .transition().delay(1000).duration(500).style("opacity", 1);
            },
            'sunburst': function(svg, width, height, defs) {
                const sunburstData = {
                    name: "root",
                    children: [
                        { name: "Category 1", color: "#3b82f6", children: [{ name: "Sub 1.1", value: 10 }, { name: "Sub 1.2", value: 15 }] },
                        { name: "Category 2", color: "#10b981", children: [{ name: "Sub 2.1", value: 20 }, { name: "Sub 2.2", value: 5 }] },
                        { name: "Category 3", color: "#ef4444", value: 30 }
                    ]
                };
                const sunburstRadius = Math.min(width, height) / 2;
                const partition = d3.partition().size([2 * Math.PI, sunburstRadius]);
                const rootSunburst = d3.hierarchy(sunburstData).sum(d => d.value).sort((a, b) => b.value - a.value);
                partition(rootSunburst);
                const arcSunburst = d3.arc().startAngle(d => d.x0).endAngle(d => d.x1).innerRadius(d => d.y0).outerRadius(d => d.y1);
                const colorSunburst = d3.scaleOrdinal(d3.schemeCategory10);
                const sunburstGroup = svg.attr("transform", `translate(${width / 2},${height / 2})`);
                sunburstGroup.selectAll("path").data(rootSunburst.descendants().filter(d => d.depth)).enter().append("path")
                    .attr("class", "sunburst-chart path").attr("display", d => d.depth ? null : "none").attr("d", arcSunburst)
                    .attr("fill", d => { while (d.depth > 1) d = d.parent; return d.data.color || colorSunburst(d.data.name); })
                    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 50).style("opacity", 1);
            },
            'sankey': function(svg, width, height, defs) {
                const sankeyNodes = [
                    { name: "Source A" }, { name: "Source B" }, { name: "Mid C" }, { name: "Mid D" },
                    { name: "Target E" }, { name: "Target F" }
                ];
                const sankeyLinks = [
                    { source: 0, target: 2, value: 30 }, { source: 0, target: 3, value: 20 },
                    { source: 1, target: 2, value: 10 }, { source: 1, target: 3, value: 40 },
                    { source: 2, target: 4, value: 35 }, { source: 2, target: 5, value: 5 },
                    { source: 3, target: 4, value: 20 }, { source: 3, target: 5, value: 40 }
                ];
                sankeyNodes[0].x = 0; sankeyNodes[0].y = height * 0.2;
                sankeyNodes[1].x = 0; sankeyNodes[1].y = height * 0.7;
                sankeyNodes[2].x = width / 2; sankeyNodes[2].y = height * 0.3;
                sankeyNodes[3].x = width / 2; sankeyNodes[3].y = height * 0.6;
                sankeyNodes[4].x = width; sankeyNodes[4].y = height * 0.2;
                sankeyNodes[5].x = width; sankeyNodes[5].y = height * 0.7;
                const nodeWidth = 20;
                const nodeHeightScale = d3.scaleLinear().domain([0, d3.max(sankeyLinks, d => d.value)]).range([10, 80]);
                svg.selectAll(".node").data(sankeyNodes).enter().append("rect")
                    .attr("class", "sankey-diagram rect")
                    .attr("x", d => d.x).attr("y", d => d.y - nodeHeightScale(d3.sum(sankeyLinks, l => (l.source.index === sankeyNodes.indexOf(d) || l.target.index === sankeyNodes.indexOf(d)) ? l.value : 0)) / 2)
                    .attr("width", nodeWidth).attr("height", d => nodeHeightScale(d3.sum(sankeyLinks, l => (l.source.index === sankeyNodes.indexOf(d) || l.target.index === sankeyNodes.indexOf(d)) ? l.value : 0)))
                    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 100).style("opacity", 1);
                svg.selectAll(".link").data(sankeyLinks).enter().append("path")
                    .attr("class", "sankey-diagram path")
                    .attr("d", d => {
                        const sourceNode = sankeyNodes[d.source];
                        const targetNode = sankeyNodes[d.target];
                        return `M${sourceNode.x + nodeWidth} ${sourceNode.y}L${targetNode.x} ${targetNode.y}`;
                    })
                    .attr("stroke-width", d => d.value / 5).attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
                    .transition().duration(1500).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
            },
            'force-directed': function(svg, width, height, defs) {
                const forceNodes = [
                    { id: "A" }, { id: "B" }, { id: "C" }, { id: "D" }, { id: "E" }
                ];
                const forceLinks = [
                    { source: "A", target: "B" }, { source: "A", target: "C" },
                    { source: "B", target: "D" }, { source: "C", target: "E" },
                    { source: "D", target: "E" }
                ];
                forceNodes[0].x = width * 0.2; forceNodes[0].y = height * 0.5;
                forceNodes[1].x = width * 0.4; forceNodes[1].y = height * 0.2;
                forceNodes[2].x = width * 0.4; forceNodes[2].y = height * 0.8;
                forceNodes[3].x = width * 0.7; forceNodes[3].y = height * 0.3;
                forceNodes[4].x = width * 0.7; forceNodes[4].y = height * 0.7;
                svg.selectAll("line").data(forceLinks).enter().append("line")
                    .attr("class", "force-directed-graph line")
                    .attr("x1", d => forceNodes.find(n => n.id === d.source).x).attr("y1", d => forceNodes.find(n => n.id === d.source).y)
                    .attr("x2", d => forceNodes.find(n => n.id === d.target).x).attr("y2", d => forceNodes.find(n => n.id === d.target).y)
                    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 100).style("opacity", 1);
                svg.selectAll("circle").data(forceNodes).enter().append("circle")
                    .attr("class", "force-directed-graph circle")
                    .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", 0)
                    .transition().duration(800).delay((d, i) => i * 150).attr("r", 8);
                svg.selectAll("text").data(forceNodes).enter().append("text")
                    .attr("x", d => d.x + 10).attr("y", d => d.y + 4).text(d => d.id)
                    .style("font-size", "12px").style("fill", "currentColor").style("opacity", 0)
                    .transition().delay(800).duration(500).style("opacity", 1);
            }
        };

        // Simplified code snippets for display
        const chartCodeSnippets = {
            'bar': `
const barData = [{ category: 'A', value: 30 }, ...];
const xBar = d3.scaleBand().range([0, width]).padding(0.1).domain(barData.map(d => d.category));
const yBar = d3.scaleLinear().range([height, 0]).domain([0, d3.max(barData, d => d.value)]);
svg.selectAll(".bar").data(barData).enter().append("rect")
    .attr("x", d => xBar(d.category)).attr("width", xBar.bandwidth())
    .attr("y", height).attr("height", 0)
    .transition().duration(800).delay((d, i) => i * 100)
    .attr("y", d => yBar(d.value)).attr("height", d => height - yBar(d.value));
`,
            'line': `
const lineData = [{ date: new Date("2023-01-01"), value: 50 }, ...];
const xLine = d3.scaleTime().range([0, width]).domain(d3.extent(lineData, d => d.date));
const yLine = d3.scaleLinear().range([height, 0]).domain([0, d3.max(lineData, d => d.value) + 10]);
const line = d3.line().x(d => xLine(d.date)).y(d => yLine(d.value));
svg.append("path").datum(lineData).attr("d", line)
    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
    .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
`,
            'pie': `
const pieData = [{ label: 'Red', value: 30 }, ...];
const radius = Math.min(width, height) / 2;
const pie = d3.pie().value(d => d.value);
const arc = d3.arc().innerRadius(0).outerRadius(radius);
const color = d3.scaleOrdinal(d3.schemeCategory10);
const arcs = svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`).selectAll("arc").data(pie(pieData)).enter().append("g");
arcs.append("path").attr("d", arc).attr("fill", (d, i) => color(i))
    .transition().duration(750).attrTween("d", function(d) {
        const interpolate = d3.interpolate(this._current, d);
        this._current = interpolate(0); return function(t) { return arc(interpolate(t)); };
    });
`,
            'donut': `
const donutData = [{ label: 'A', value: 40 }, ...];
const donutRadius = Math.min(width, height) / 2;
const innerRadius = donutRadius * 0.6;
const donutPie = d3.pie().value(d => d.value);
const donutArc = d3.arc().innerRadius(innerRadius).outerRadius(donutRadius);
const donutColor = d3.scaleOrdinal(d3.schemeSet2);
const donutArcs = svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`).selectAll("arc").data(donutPie(donutData)).enter().append("g");
donutArcs.append("path").attr("d", donutArc).attr("fill", (d, i) => donutColor(i))
    .transition().duration(750).attrTween("d", function(d) {
        const interpolate = d3.interpolate(this._current, d);
        this._current = interpolate(0); return function(t) { return donutArc(interpolate(t)); };
    });
`,
            'area': `
const areaData = [{ date: new Date("2023-01-01"), value: 30 }, ...];
const xArea = d3.scaleTime().range([0, width]).domain(d3.extent(areaData, d => d.date));
const yArea = d3.scaleLinear().range([height, 0]).domain([0, d3.max(areaData, d => d.value) + 10]);
const area = d3.area().x(d => xArea(d.date)).y0(height).y1(d => yArea(d.value));
svg.append("path").datum(areaData).attr("d", area).style("opacity", 0)
    .transition().duration(1500).style("opacity", 1);
`,
            'scatter': `
const scatterData = [{ x: 10, y: 80, size: 5 }, ...];
const xScatter = d3.scaleLinear().range([0, width]).domain([0, 60]);
const yScatter = d3.scaleLinear().range([height, 0]).domain([0, 100]);
svg.selectAll(".dot").data(scatterData).enter().append("circle")
    .attr("cx", d => xScatter(d.x)).attr("cy", d => yScatter(d.y)).attr("r", 0)
    .transition().duration(800).delay((d, i) => i * 100).attr("r", d => d.size);
`,
            'bubble': `
const bubbleData = [{ x: 10, y: 80, r: 15, label: 'Item 1' }, ...];
const xBubble = d3.scaleLinear().range([0, width]).domain([0, 100]);
const yBubble = d3.scaleLinear().range([height, 0]).domain([0, 100]);
svg.selectAll(".bubble").data(bubbleData).enter().append("circle")
    .attr("cx", d => xBubble(d.x)).attr("cy", d => yBubble(d.y)).attr("r", 0)
    .transition().duration(1000).delay((d, i) => i * 150).attr("r", d => d.r);
`,
            'radar': `
const radarData = [{ skill: 'Strength', value: 0.8 }, ...];
const radarRadius = Math.min(width, height) / 2 - 20;
const centerX = width / 2; const centerY = height / 2;
const angleSlice = Math.PI * 2 / radarData.length;
const rScale = d3.scaleLinear().range([0, radarRadius]).domain([0, 1]);
const radarLine = d3.lineRadial().radius(d => rScale(d.value)).angle((d, i) => i * angleSlice);
svg.append("path").datum(radarData.concat(radarData[0])).attr("d", radarLine)
    .attr("transform", \`translate(\${centerX},\${centerY})\`).style("opacity", 0)
    .transition().duration(1500).style("opacity", 1);
`,
            'heatmap': `
const heatmapData = [{ row: 'A', col: 'X', value: 10 }, ...];
const rows = Array.from(new Set(heatmapData.map(d => d.row)));
const cols = Array.from(new Set(heatmapData.map(d => d.col)));
const xHeatmap = d3.scaleBand().range([0, width]).domain(cols).padding(0.05);
const yHeatmap = d3.scaleBand().range([height, 0]).domain(rows).padding(0.05);
const colorHeatmap = d3.scaleSequential(d3.interpolateViridis).domain([0, 100]);
svg.selectAll(".cell").data(heatmapData).enter().append("rect")
    .attr("x", d => xHeatmap(d.col)).attr("y", d => yHeatmap(d.row))
    .attr("width", xHeatmap.bandwidth()).attr("height", yHeatmap.bandwidth())
    .attr("fill", d => colorHeatmap(d.value)).style("opacity", 0)
    .transition().duration(800).delay((d, i) => i * 50).style("opacity", 1);
`,
            'treemap': `
const treemapData = { name: "root", children: [{ name: "Category A", size: 100 }, ...] };
const treemap = d3.treemap().size([width, height]).padding(1);
const root = d3.hierarchy(treemapData).sum(d => d.size).sort((a, b) => b.height - a.height || b.value - a.value);
treemap(root);
svg.selectAll(".node").data(root.leaves()).enter().append("rect")
    .attr("x", d => d.x0).attr("y", d => d.y0).attr("width", d => d.x1 - d.x0).attr("height", d => d.y1 - d.y0)
    .attr("fill", d => d.data.color).style("opacity", 0)
    .transition().duration(1000).delay((d, i) => i * 100).style("opacity", 1);
`,
            'gauge': `
const gaugeValue = 75;
const gaugeRadius = Math.min(width, height) / 2 - 20;
const arcGauge = d3.arc().innerRadius(gaugeRadius * 0.7).outerRadius(gaugeRadius).startAngle(-Math.PI / 2);
const backgroundArc = arcGauge.endAngle(Math.PI / 2);
const foregroundArc = arcGauge.endAngle(Math.PI / 2 * (gaugeValue / 100) - Math.PI / 2);
const gaugeGroup = svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`);
gaugeGroup.append("path").attr("d", backgroundArc).attr("fill", "#e2e8f0");
gaugeGroup.append("path").attr("d", foregroundArc).attr("fill", "#3b82f6")
    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
    .transition().duration(1500).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
`,
            'progress': `
const progressData = [{ label: 'Task 1', value: 90, color: '#3b82f6' }, ...];
const barHeight = 20; const padding = 10;
const xScale = d3.scaleLinear().range([0, width]).domain([0, 100]);
const progressGroup = svg.append("g").attr("transform", \`translate(0,\${(height - progressData.length * (barHeight + padding)) / 2})\`);
progressGroup.selectAll(".progress-bar").data(progressData).enter().append("rect")
    .attr("x", 0).attr("y", (d, i) => i * (barHeight + padding)).attr("height", barHeight)
    .attr("fill", d => d.color).attr("width", 0)
    .transition().duration(1000).delay((d, i) => i * 150).attr("width", d => xScale(d.value));
`,
            'stacked-bar': `
const stackedData = [{ category: 'A', value1: 20, value2: 30, value3: 10 }, ...];
const keys = ['value1', 'value2', 'value3'];
const stackedColors = d3.scaleOrdinal(d3.schemeCategory10);
const xStacked = d3.scaleBand().range([0, width]).padding(0.1).domain(stackedData.map(d => d.category));
const yStacked = d3.scaleLinear().range([height, 0]).domain([0, d3.max(stackedData, d => d.value1 + d.value2 + d.value3)]);
const stack = d3.stack().keys(keys);
const stackedSeries = stack(stackedData);
svg.selectAll(".stacked-group").data(stackedSeries).enter().append("g")
    .attr("fill", d => stackedColors(d.key)).selectAll("rect").data(d => d).enter().append("rect")
    .attr("x", d => xStacked(d.data.category)).attr("width", xStacked.bandwidth())
    .attr("y", height).attr("height", 0)
    .transition().duration(800).delay((d, i) => i * 100)
    .attr("y", d => yStacked(d[1])).attr("height", d => yStacked(d[0]) - yStacked(d[1]));
`,
            'grouped-bar': `
const groupedData = [{ category: 'A', group1: 20, group2: 30 }, ...];
const groupedKeys = ['group1', 'group2'];
const groupedColors = d3.scaleOrdinal(d3.schemeSet1);
const xGrouped0 = d3.scaleBand().rangeRound([0, width]).paddingInner(0.1).domain(groupedData.map(d => d.category));
const xGrouped1 = d3.scaleBand().padding(0.05).domain(groupedKeys).rangeRound([0, xGrouped0.bandwidth()]);
const yGrouped = d3.scaleLinear().rangeRound([height, 0]).domain([0, d3.max(groupedData, d => d3.max(groupedKeys, key => d[key]))]);
svg.append("g").selectAll("g").data(groupedData).enter().append("g")
    .attr("transform", d => \`translate(\${xGrouped0(d.category)},0)\`).selectAll("rect").data(d => groupedKeys.map(key => ({ key: key, value: d[key] })))
    .enter().append("rect")
    .attr("x", d => xGrouped1(d.key)).attr("width", xGrouped1.bandwidth()).attr("fill", d => groupedColors(d.key))
    .attr("y", height).attr("height", 0)
    .transition().duration(800).delay((d, i) => i * 100)
    .attr("y", d => yGrouped(d.value)).attr("height", d => height - yGrouped(d.value));
`,
            'candlestick': `
const candlestickData = [{ date: "Day 1", open: 50, close: 60, high: 65, low: 45 }, ...];
const xCandle = d3.scaleBand().range([0, width]).padding(0.5).domain(candlestickData.map(d => d.date));
const yCandle = d3.scaleLinear().range([height, 0]).domain([d3.min(candlestickData, d => d.low) - 5, d3.max(candlestickData, d => d.high) + 5]);
svg.selectAll(".wick").data(candlestickData).enter().append("line")
    .attr("x1", d => xCandle(d.date) + xCandle.bandwidth() / 2).attr("x2", d => xCandle(d.date) + xCandle.bandwidth() / 2)
    .attr("y1", d => yCandle(d.low)).attr("y2", d => yCandle(d.high)).attr("stroke", "currentColor").attr("stroke-width", 1);
svg.selectAll(".body").data(candlestickData).enter().append("rect")
    .attr("x", d => xCandle(d.date)).attr("y", d => yCandle(Math.max(d.open, d.close)))
    .attr("width", xCandle.bandwidth()).attr("height", d => Math.abs(yCandle(d.open) - yCandle(d.close)))
    .attr("fill", d => d.open > d.close ? "#ef4444" : "#10b981").style("opacity", 0)
    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 1);
`,
            'waterfall': `
const waterfallData = [{ label: "Start", value: 100, type: "start" }, ...];
let cumulative = 0;
waterfallData.forEach((d, i) => { /* calculate start/end */ });
const xWaterfall = d3.scaleBand().range([0, width]).padding(0.2).domain(waterfallData.map(d => d.label));
const yWaterfall = d3.scaleLinear().range([height, 0]).domain([d3.min(waterfallData, d => Math.min(d.start, d.end)) - 10, d3.max(waterfallData, d => Math.max(d.start, d.end)) + 10]);
svg.selectAll(".bar").data(waterfallData).enter().append("rect")
    .attr("x", d => xWaterfall(d.label)).attr("width", xWaterfall.bandwidth())
    .attr("y", d => yWaterfall(Math.max(d.start, d.end))).attr("height", d => Math.abs(yWaterfall(d.start) - yWaterfall(d.end)))
    .attr("fill", d => { /* color logic */ }).style("opacity", 0)
    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 1);
`,
            'stacked-area': `
const stackedAreaData = [{ date: new Date("2023-01-01"), value1: 10, value2: 15, value3: 5 }, ...];
const stackedAreaKeys = ['value1', 'value2', 'value3'];
const stackedAreaColors = d3.scaleOrdinal(d3.schemePastel1);
const xStackedArea = d3.scaleTime().range([0, width]).domain(d3.extent(stackedAreaData, d => d.date));
const yStackedArea = d3.scaleLinear().range([height, 0]).domain([0, d3.max(stackedAreaData, d => d.value1 + d.value2 + d.value3)]);
const stackedArea = d3.area().x(d => xStackedArea(d.data.date)).y0(d => yStackedArea(d[0])).y1(d => yStackedArea(d[1]));
const stackArea = d3.stack().keys(stackedAreaKeys);
const stackedAreaSeries = stackArea(stackedAreaData);
svg.selectAll(".stacked-area").data(stackedAreaSeries).enter().append("path")
    .attr("fill", d => stackedAreaColors(d.key)).attr("d", stackedArea)
    .style("opacity", 0).transition().duration(1500).delay((d, i) => i * 200).style("opacity", 0.8);
`,
            'radial-bar': `
const radialBarData = [{ category: 'A', value: 70 }, ...];
const radialRadius = Math.min(width, height) / 2 - 20;
const radialInnerRadius = 50;
const xRadial = d3.scaleBand().range([0, 2 * Math.PI]).align(0).domain(radialBarData.map(d => d.category));
const yRadial = d3.scaleRadial().range([radialInnerRadius, radialRadius]).domain([0, 100]);
const radialArc = d3.arc().innerRadius(radialInnerRadius).outerRadius(d => yRadial(d.value))
    .startAngle(d => xRadial(d.category)).endAngle(d => xRadial(d.category) + xRadial.bandwidth()).padAngle(0.01);
const radialColor = d3.scaleOrdinal(d3.schemeSpectral[radialBarData.length]);
svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`).selectAll("path").data(radialBarData).enter().append("path")
    .attr("fill", (d, i) => radialColor(i)).attr("d", radialArc)
    .style("opacity", 0).transition().duration(1000).delay((d, i) => i * 150).style("opacity", 1);
`,
            'bullet': `
const bulletData = { title: "Revenue", subtitle: "USD", ranges: [150, 225, 300], measures: [270], markers: [250] };
const xBullet = d3.scaleLinear().range([0, width]).domain([0, d3.max(bulletData.ranges)]);
const bulletHeight = 30; const bulletY = (height - bulletHeight) / 2;
svg.selectAll("rect.range").data(bulletData.ranges).enter().append("rect")
    .attr("height", bulletHeight).attr("x", 0).attr("y", bulletY).attr("width", d => xBullet(d))
    .attr("fill", (d, i) => ["#ef4444", "#f59e0b", "#10b981"][i]).style("opacity", 0)
    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 0.6);
svg.selectAll("rect.measure").data(bulletData.measures).enter().append("rect")
    .attr("height", bulletHeight / 2).attr("x", 0).attr("y", bulletY + bulletHeight / 4).attr("width", 0)
    .attr("fill", "#3b82f6").transition().duration(1200).attr("width", d => xBullet(d));
`,
            'box-plot': `
const boxData = [{ category: "Group 1", min: 10, q1: 20, median: 30, q3: 40, max: 50 }, ...];
const xBox = d3.scaleBand().range([0, width]).padding(0.5).domain(boxData.map(d => d.category));
const yBox = d3.scaleLinear().range([height, 0]).domain([0, 60]);
const boxWidth = xBox.bandwidth() * 0.7;
const boxes = svg.selectAll(".box-group").data(boxData).enter().append("g")
    .attr("transform", d => \`translate(\${xBox(d.category) + (xBox.bandwidth() - boxWidth) / 2},0)\`);
boxes.append("rect").attr("x", 0).attr("y", d => yBox(d.q3)).attr("width", boxWidth)
    .attr("height", d => yBox(d.q1) - yBox(d.q3)).attr("fill", "#3b82f6").style("opacity", 0)
    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 0.7);
`,
            'choropleth': `
const choroplethData = [{ region: "North", value: 80, color: "#a7f3d0" }, ...];
const xChoropleth = d3.scaleBand().range([0, width]).padding(0.1).domain(choroplethData.map(d => d.region));
const yChoropleth = d3.scaleLinear().range([height, 0]).domain([0, 100]);
svg.selectAll(".region").data(choroplethData).enter().append("rect")
    .attr("x", d => xChoropleth(d.region)).attr("y", height).attr("width", xChoropleth.bandwidth()).attr("height", 0)
    .attr("fill", d => d.color).transition().duration(800).delay((d, i) => i * 100)
    .attr("y", d => yChoropleth(d.value)).attr("height", d => height - yChoropleth(d.value));
`,
            'streamgraph': `
const streamData = [{ year: new Date("2020"), a: 20, b: 10, c: 5 }, ...];
const streamKeys = ['a', 'b', 'c'];
const streamColors = d3.scaleOrdinal(d3.schemeCategory10);
const xStream = d3.scaleTime().range([0, width]).domain(d3.extent(streamData, d => d.year));
const yStream = d3.scaleLinear().range([height, 0]);
const stackStream = d3.stack().keys(streamKeys).offset(d3.stackOffsetWiggle);
const streamSeries = stackStream(streamData);
yStream.domain([d3.min(streamSeries, layer => d3.min(layer, d => d[0])), d3.max(streamSeries, layer => d3.max(layer, d => d[1]))]);
const areaStream = d3.area().x(d => xStream(d.data.year)).y0(d => yStream(d[0])).y1(d => yStream(d[1])).curve(d3.curveBasis);
svg.selectAll(".stream").data(streamSeries).enter().append("path")
    .attr("fill", d => streamColors(d.key)).attr("d", areaStream).style("opacity", 0)
    .transition().duration(1500).delay((d, i) => i * 200).style("opacity", 0.7);
`,
            'tree': `
const treeData = { name: "Root", children: [{ name: "Branch A", children: [...] }, ...] };
const treeLayout = d3.tree().size([height, width - 100]);
const rootTree = d3.hierarchy(treeData); treeLayout(rootTree);
svg.selectAll(".link").data(rootTree.links()).enter().append("path")
    .attr("fill", "none").attr("stroke", "#94a3b8").attr("stroke-opacity", 0.6).attr("stroke-width", 1)
    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
    .transition().duration(1500).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
`,
            'word-cloud': `
const words = [{ text: "Data", size: 40 }, { text: "Visualization", size: 35 }, ...];
const wordColor = d3.scaleOrdinal(d3.schemePaired);
svg.selectAll("text").data(words).enter().append("text")
    .attr("x", () => Math.random() * width).attr("y", () => Math.random() * height)
    .attr("text-anchor", "middle").style("font-size", 0).style("fill", (d, i) => wordColor(i)).text(d => d.text)
    .transition().duration(1000).delay((d, i) => i * 100).style("font-size", d => \`\${d.size}px\`);
`,
            'parallel-coordinates': `
const pcData = [{ A: 10, B: 50, C: 20, D: 80 }, ...];
const pcDimensions = ['A', 'B', 'C', 'D'];
const pcColors = d3.scaleOrdinal(d3.schemeCategory10);
const yPc = {}; pcDimensions.forEach(dim => { yPc[dim] = d3.scaleLinear().domain([0, 100]).range([height, 0]); });
const xPc = d3.scalePoint().range([0, width]).padding(1).domain(pcDimensions);
const pathPc = function(d) { return d3.line()(pcDimensions.map(p => [xPc(p), yPc[p](d[p])])); };
svg.selectAll(".line").data(pcData).enter().append("path")
    .attr("d", pathPc).attr("fill", "none").attr("stroke", (d, i) => pcColors(i)).attr("stroke-width", 2).style("opacity", 0.7)
    .attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
    .transition().duration(1500).delay((d, i) => i * 200).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
`,
            'polar-area': `
const polarData = [{ label: 'Energy', value: 70 }, ...];
const polarRadius = Math.min(width, height) / 2 - 20;
const polarAngle = d3.scaleBand().range([0, 2 * Math.PI]).align(0).domain(polarData.map(d => d.label));
const polarRadiusScale = d3.scaleLinear().range([0, polarRadius]).domain([0, 100]);
const polarArc = d3.arc().innerRadius(0).outerRadius(d => polarRadiusScale(d.data.value))
    .startAngle(d => polarAngle(d.data.label)).endAngle(d => polarAngle(d.data.label) + polarAngle.bandwidth()).padAngle(0.01);
const polarColor = d3.scaleOrdinal(d3.schemeSet3);
const polarGroup = svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`);
polarGroup.selectAll("path").data(d3.pie().value(d => d.value).sort(null)(polarData)).enter().append("path")
    .attr("fill", (d, i) => polarColor(i)).attr("d", polarArc).style("opacity", 0)
    .transition().duration(1000).delay((d, i) => i * 150).style("opacity", 0.8);
`,
            'funnel': `
const funnelData = [{ stage: "Awareness", value: 100 }, ...];
const funnelMax = d3.max(funnelData, d => d.value);
const yFunnel = d3.scaleBand().range([0, height]).padding(0.1).domain(funnelData.map(d => d.stage));
const xFunnel = d3.scaleLinear().range([0, width]).domain([0, funnelMax]);
const funnelColors = d3.scaleSequential(d3.interpolateBlues).domain([0, funnelData.length]);
svg.selectAll(".funnel-rect").data(funnelData).enter().append("rect")
    .attr("x", d => (width - xFunnel(d.value)) / 2).attr("y", d => yFunnel(d.stage))
    .attr("width", d => xFunnel(d.value)).attr("height", yFunnel.bandwidth()).attr("fill", (d, i) => funnelColors(i))
    .style("opacity", 0).transition().duration(800).delay((d, i) => i * 100).style("opacity", 0.8);
`,
            'pyramid': `
const pyramidData = [{ age: "0-14", male: 10, female: 12 }, ...];
const xPyramid = d3.scaleLinear().range([0, width]).domain([-d3.max(pyramidData, d => Math.max(d.male, d.female)), d3.max(pyramidData, d => Math.max(d.male, d.female))]);
const yPyramid = d3.scaleBand().range([height, 0]).padding(0.1).domain(pyramidData.map(d => d.age));
svg.selectAll(".bar-male").data(pyramidData).enter().append("rect")
    .attr("x", d => xPyramid(0) - xPyramid(d.male)).attr("y", d => yPyramid(d.age))
    .attr("width", 0).attr("height", yPyramid.bandwidth()).attr("fill", "#3b82f6")
    .transition().duration(800).delay((d, i) => i * 100).attr("width", d => xPyramid(d.male) - xPyramid(0));
svg.selectAll(".bar-female").data(pyramidData).enter().append("rect")
    .attr("x", xPyramid(0)).attr("y", d => yPyramid(d.age)).attr("width", 0).attr("height", yPyramid.bandwidth())
    .attr("fill", "#ef4444").transition().duration(800).delay((d, i) => i * 100).attr("width", d => xPyramid(d.female) - xPyramid(0));
`,
            'bullet-list': `
const bulletListData = [{ title: "Sales", subtitle: "kUSD", ranges: [150, 225, 300], measures: [270], markers: [250] }, ...];
const bulletListHeight = 50; const bulletListPadding = 10;
bulletListData.forEach((data, i) => {
    const bulletGroup = svg.append("g").attr("transform", \`translate(0,\${i * (bulletListHeight + bulletListPadding)})\`);
    const xBulletList = d3.scaleLinear().range([0, width]).domain([0, d3.max(data.ranges)]);
    bulletGroup.selectAll("rect.range").data(data.ranges).enter().append("rect")
        .attr("height", bulletListHeight).attr("x", 0).attr("y", 0).attr("width", d => xBulletList(d))
        .attr("fill", (d, idx) => ["#ef4444", "#f59e0b", "#10b981"][idx]).style("opacity", 0)
        .transition().duration(800).delay((idx) => i * 200 + idx * 100).style("opacity", 0.6);
});
`,
            'calendar-heatmap': `
const calendarData = Array.from({ length: 365 }, (_, i) => ({ date: new Date(2024, 0, i + 1), value: Math.floor(Math.random() * 100) }));
const cellSize = 15;
const weekDay = d => d.getDay(); const weekOfYear = d => d3.timeWeek.count(d3.timeYear(d), d);
const colorCalendar = d3.scaleSequential(d3.interpolateGreens).domain([0, 100]);
svg.attr("transform", \`translate(20,20)\`);
svg.selectAll(".day").data(calendarData).enter().append("rect")
    .attr("width", cellSize).attr("height", cellSize).attr("x", d => weekOfYear(d.date) * cellSize).attr("y", d => weekDay(d.date) * cellSize)
    .attr("fill", d => colorCalendar(d.value)).style("opacity", 0)
    .transition().duration(500).delay((d, i) => i * 5).style("opacity", 1);
`,
            'chord-matrix': `
const matrixData = [[0, 10, 20], [15, 0, 5], [8, 25, 0]];
const matrixLabels = ["A", "B", "C"];
const xMatrix = d3.scaleBand().range([0, width]).padding(0.05).domain(matrixLabels);
const yMatrix = d3.scaleBand().range([0, height]).padding(0.05).domain(matrixLabels);
const colorMatrix = d3.scaleSequential(d3.interpolatePurples).domain([0, d3.max(matrixData.flat())]);
matrixData.forEach((row, i) => {
    row.forEach((value, j) => {
        svg.append("rect").attr("x", xMatrix(matrixLabels[j])).attr("y", yMatrix(matrixLabels[i]))
            .attr("width", xMatrix.bandwidth()).attr("height", yMatrix.bandwidth())
            .attr("fill", colorMatrix(value)).style("opacity", 0)
            .transition().duration(800).delay((i * matrixData[0].length + j) * 50).style("opacity", 1);
    });
});
`,
            'packed-circles': `
const packedData = { name: "Root", children: [{ name: "Group 1", value: 50 }, ...] };
const pack = d3.pack().size([width, height]).padding(2);
const rootPacked = d3.hierarchy(packedData).sum(d => d.value).sort((a, b) => b.value - a.value);
const nodesPacked = pack(rootPacked).descendants();
const packedColor = d3.scaleSequential(d3.interpolateMagma).domain([0, d3.max(nodesPacked, d => d.depth)]);
svg.selectAll("circle").data(nodesPacked).enter().append("circle")
    .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", 0)
    .attr("fill", d => packedColor(d.depth)).style("opacity", 0.8)
    .transition().duration(800).delay((d, i) => i * 50).attr("r", d => d.r);
`,
            'density-plot': `
const densityData = Array.from({ length: 100 }, () => Math.random() * 100);
const xDensity = d3.scaleLinear().range([0, width]).domain([0, 100]);
const histogram = d3.histogram().value(d => d).domain(xDensity.domain()).thresholds(xDensity.ticks(40));
const bins = histogram(densityData);
const yDensity = d3.scaleLinear().range([height, 0]).domain([0, d3.max(bins, d => d.length)]);
const densityLine = d3.line().curve(d3.curveBasis).x(d => xDensity(d.x0 + (d.x1 - d.x0) / 2)).y(d => yDensity(d.length));
svg.append("path").datum(bins).attr("fill", "none").attr("stroke", "#3b82f6").attr("stroke-width", 3)
    .attr("d", densityLine).attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
    .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
`,
            'polar-line': `
const polarLineData = [{ angle: 0, value: 50 }, ...];
const polarLineRadius = Math.min(width, height) / 2 - 20;
const polarLineAngleScale = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 360]);
const polarLineRadiusScale = d3.scaleLinear().range([0, polarLineRadius]).domain([0, 100]);
const polarLine = d3.lineRadial().radius(d => polarLineRadiusScale(d.value)).angle(d => polarLineAngleScale(d.angle)).curve(d3.curveCardinalClosed);
const polarLineGroup = svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`);
polarLineGroup.append("path").datum(polarLineData).attr("fill", "none").attr("stroke", "#ef4444").attr("stroke-width", 3)
    .attr("d", polarLine).attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() })
    .transition().duration(2000).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
`,
            'gauge-multi': `
const gaugeMultiData = [{ value: 40, label: "Low", color: "#ef4444" }, ...];
const gaugeMultiCurrentValue = 75;
const gaugeMultiRadius = Math.min(width, height) / 2 - 20;
const gaugeMultiInnerRadius = gaugeMultiRadius * 0.7;
const gaugeMultiGroup = svg.attr("transform", \`translate(\${width / 2},\${height / 2}) rotate(-90)\`);
let currentAngle = 0;
gaugeMultiData.forEach((d, i) => {
    const startAngle = currentAngle; const endAngle = currentAngle + (d.value / 100) * Math.PI;
    gaugeMultiGroup.append("path").attr("d", d3.arc().innerRadius(gaugeMultiInnerRadius).outerRadius(gaugeMultiRadius).startAngle(startAngle).endAngle(startAngle))
        .attr("fill", d.color).transition().duration(800).delay(i * 200)
        .attrTween("d", function(t) { /* interpolation logic */ });
    currentAngle = endAngle;
});
`,
            'timeline': `
const timelineData = [{ date: new Date("2023-01-15"), event: "Project Start" }, ...];
const xTimeline = d3.scaleTime().range([0, width]).domain(d3.extent(timelineData, d => d.date));
const yTimeline = height / 2;
svg.append("line").attr("x1", 0).attr("x2", width).attr("y1", yTimeline).attr("y2", yTimeline).attr("stroke", "#cbd5e1").attr("stroke-width", 2);
svg.selectAll(".event-circle").data(timelineData).enter().append("circle")
    .attr("cx", d => xTimeline(d.date)).attr("cy", yTimeline).attr("r", 0).attr("fill", "#3b82f6").attr("stroke", "white").attr("stroke-width", 2)
    .transition().duration(800).delay((d, i) => i * 150).attr("r", 8);
`,
            'chord-simple': `
const simpleChordData = [[0, 15, 20], [10, 0, 5], [8, 12, 0]];
const simpleChordNames = ["Alice", "Bob", "Charlie"];
const chordLayout = d3.chord().padAngle(0.05).sortSubgroups(d3.descending)(simpleChordData);
const chordArcSimple = d3.arc().innerRadius(Math.min(width, height) / 2 - 50).outerRadius(Math.min(width, height) / 2 - 30);
const ribbon = d3.ribbon().radius(Math.min(width, height) / 2 - 50);
const simpleChordColor = d3.scaleOrdinal(d3.schemeCategory10);
const simpleChordGroup = svg.attr("transform", \`translate(\${width / 2},\${height / 2})\`);
simpleChordGroup.selectAll("g.arc").data(chordLayout.groups).enter().append("g").append("path")
    .attr("fill", d => simpleChordColor(d.index)).attr("d", chordArcSimple).style("opacity", 0)
    .transition().duration(800).delay((d, i) => i * 100).style("opacity", 1);
simpleChordGroup.selectAll("path.ribbon").data(chordLayout).enter().append("path")
    .attr("d", ribbon).attr("fill", d => simpleChordColor(d.source.index)).attr("stroke", d => d3.rgb(simpleChordColor(d.source.index)).darker())
    .attr("stroke-width", 1).style("opacity", 0).transition().duration(1200).delay((d, i) => i * 150).style("opacity", 0.7);
`,
            '3d-bar': `
// Three.js 3D Bar Chart
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(width, height);
container.appendChild(renderer.domElement);

const barData3D = [
    { x: -2, y: 0, z: 0, height: 3, color: 0x3b82f6 },
    { x: 0, y: 0, z: 0, height: 5, color: 0x10b981 },
    { x: 2, y: 0, z: 0, height: 2, color: 0xef4444 }
];

barData3D.forEach(data => {
    const geometry = new THREE.BoxGeometry(0.8, data.height, 0.8);
    const material = new THREE.MeshLambertMaterial({ color: data.color });
    const bar = new THREE.Mesh(geometry, material);
    bar.position.set(data.x, data.height / 2, data.z);
    bar.scale.y = 0.001; // Start small for animation
    scene.add(bar);

    new TWEEN.Tween(bar.scale)
        .to({ y: 1 }, 1000)
        .easing(TWEEN.Easing.Elastic.Out)
        .delay(500)
        .start();
});

const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1).normalize();
scene.add(directionalLight);

camera.position.z = 8;
camera.position.y = 4;
camera.lookAt(0, 2, 0);

let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };

function toRadians(angle) { return angle * (Math.PI / 180); }

container.addEventListener('mousedown', (e) => {
    isDragging = true;
    previousMousePosition = { x: e.clientX, y: e.clientY };
    container.style.cursor = 'grabbing';
});

container.addEventListener('mouseup', () => {
    isDragging = false;
    container.style.cursor = 'grab';
});

container.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const deltaX = e.clientX - previousMousePosition.x;
    const deltaY = e.clientY - previousMousePosition.y;

    scene.rotation.y += toRadians(deltaX * 0.5);
    scene.rotation.x += toRadians(deltaY * 0.5);

    previousMousePosition = { x: e.clientX, y: e.clientY };
});

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    const newWidth = container.clientWidth;
    const newHeight = container.clientHeight;
    camera.aspect = newWidth / newHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(newWidth, newHeight);
});
`,
            '3d-scatter': `
// Three.js 3D Scatter Plot
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(width, height);
container.appendChild(renderer.domElement);

const scatterData3D = [
    { x: -2, y: 1, z: 0, color: 0xff0000, size: 0.2 },
    { x: 0, y: 3, z: -1, color: 0x00ff00, size: 0.3 },
    { x: 2, y: 2, z: 1, color: 0x0000ff, size: 0.25 },
    { x: -1, y: 4, z: 2, color: 0xffff00, size: 0.15 },
    { x: 1, y: 0.5, z: -2, color: 0xff00ff, size: 0.35 }
];

scatterData3D.forEach(data => {
    const geometry = new THREE.SphereGeometry(data.size, 16, 16);
    const material = new THREE.MeshLambertMaterial({ color: data.color });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.set(data.x, data.y, data.z);
    sphere.scale.set(0.001, 0.001, 0.001); // Start small for animation
    scene.add(sphere);

    new TWEEN.Tween(sphere.scale)
        .to({ x: 1, y: 1, z: 1 }, 1000)
        .easing(TWEEN.Easing.Elastic.Out)
        .delay(500)
        .start();
});

const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1).normalize();
scene.add(directionalLight);

camera.position.z = 8;
camera.position.y = 4;
camera.lookAt(0, 2, 0);

let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };

function toRadians(angle) { return angle * (Math.PI / 180); }

container.addEventListener('mousedown', (e) => {
    isDragging = true;
    previousMousePosition = { x: e.clientX, y: e.clientY };
    container.style.cursor = 'grabbing';
});

container.addEventListener('mouseup', () => {
    isDragging = false;
    container.style.cursor = 'grab';
});

container.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const deltaX = e.clientX - previousMousePosition.x;
    const deltaY = e.clientY - previousMousePosition.y;

    scene.rotation.y += toRadians(deltaX * 0.5);
    scene.rotation.x += toRadians(deltaY * 0.5);

    previousMousePosition = { x: e.clientX, y: e.clientY };
});

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    const newWidth = container.clientWidth;
    const newHeight = container.clientHeight;
    camera.aspect = newWidth / newHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(newWidth, newHeight);
});
`,
            '3d-surface': `
// Three.js 3D Surface Plot (simplified grid of points)
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(width, height);
container.appendChild(renderer.domElement);

const gridSize = 10;
const spacing = 0.5;
const points = [];

for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
        const x = (i - gridSize / 2) * spacing;
        const z = (j - gridSize / 2) * spacing;
        const y = Math.sin(x * 2 + z * 2) * 1 + Math.random() * 0.5; // Simple surface function
        points.push(new THREE.Vector3(x, y, z));
    }
}

const geometry = new THREE.BufferGeometry().setFromPoints(points);
const material = new THREE.PointsMaterial({ color: 0x3b82f6, size: 0.1 });
const pointsMesh = new THREE.Points(geometry, material);
scene.add(pointsMesh);

// Add lines to connect points (simplified grid)
for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
        const idx = i * gridSize + j;
        if (j < gridSize - 1) { // Connect horizontally
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([points[idx], points[idx + 1]]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.5 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
        }
        if (i < gridSize - 1) { // Connect vertically
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([points[idx], points[idx + gridSize]]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.5 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
        }
    }
}


const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1).normalize();
scene.add(directionalLight);

camera.position.z = 8;
camera.position.y = 4;
camera.lookAt(0, 0, 0);

let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };

function toRadians(angle) { return angle * (Math.PI / 180); }

container.addEventListener('mousedown', (e) => {
    isDragging = true;
    previousMousePosition = { x: e.clientX, y: e.clientY };
    container.style.cursor = 'grabbing';
});

container.addEventListener('mouseup', () => {
    isDragging = false;
    container.style.cursor = 'grab';
});

container.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const deltaX = e.clientX - previousMousePosition.x;
    const deltaY = e.clientY - previousMousePosition.y;

    scene.rotation.y += toRadians(deltaX * 0.5);
    scene.rotation.x += toRadians(deltaY * 0.5);

    previousMousePosition = { x: e.clientX, y: e.clientY };
});

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    const newWidth = container.clientWidth;
    const newHeight = container.clientHeight;
    camera.aspect = newWidth / newHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(newWidth, newHeight);
});
`
        };

        // Function to render charts (will be called on DOMContentLoaded)
        window.renderChart = function(chartId, chartType) {
            const container = document.getElementById(chartId + 'Chart');
            if (!container) return;

            // Clear previous chart
            container.innerHTML = '';

            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            // Define gradients (only for D3.js charts)
            let svg;
            let defs;
            if (chartType.startsWith('3d-')) {
                // Three.js charts will handle their own setup
            } else {
                svg = d3.select(container).append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                defs = svg.append("defs");

                defs.append("linearGradient")
                    .attr("id", "barGradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "0%")
                    .attr("y2", "100%")
                    .html(`
                        <stop offset="0%" stop-color="#3b82f6"/>
                        <stop offset="100%" stop-color="#10b981"/>
                    `);
                defs.append("linearGradient")
                    .attr("id", "barHoverGradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "0%")
                    .attr("y2", "100%")
                    .html(`
                        <stop offset="0%" stop-color="#60a5fa"/>
                        <stop offset="100%" stop-color="#34d399"/>
                    `);

                defs.append("linearGradient")
                    .attr("id", "lineGradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "0%")
                    .html(`
                        <stop offset="0%" stop-color="#3b82f6"/>
                        <stop offset="100%" stop-color="#10b981"/>
                    `);

                defs.append("linearGradient")
                    .attr("id", "areaGradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "0%")
                    .attr("y2", "100%")
                    .html(`
                        <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.8"/>
                        <stop offset="100%" stop-color="#10b981" stop-opacity="0.2"/>
                    `);

                defs.append("radialGradient")
                    .attr("id", "scatterGradient")
                    .attr("cx", "50%")
                    .attr("cy", "50%")
                    .attr("r", "50%")
                    .html(`
                        <stop offset="0%" stop-color="#60a5fa"/>
                        <stop offset="100%" stop-color="#3b82f6"/>
                    `);

                defs.append("radialGradient")
                    .attr("id", "bubbleGradient")
                    .attr("cx", "50%")
                    .attr("cy", "50%")
                    .attr("r", "50%")
                    .html(`
                        <stop offset="0%" stop-color="#a78bfa"/>
                        <stop offset="100%" stop-color="#d946ef"/>
                    `);

                defs.append("linearGradient")
                    .attr("id", "radarGradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "100%")
                    .html(`
                        <stop offset="0%" stop-color="#10b981" stop-opacity="0.7"/>
                        <stop offset="100%" stop-color="#3b82f6" stop-opacity="0.7"/>
                    `);

                defs.append("linearGradient")
                    .attr("id", "nodeGradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "100%")
                    .html(`
                        <stop offset="0%" stop-color="#f59e0b"/>
                        <stop offset="100%" stop-color="#ef4444"/>
                    `);
            }


            // Render chart based on type
            if (chartRenderFunctions[chartType]) {
                if (chartType.startsWith('3d-')) {
                    // For Three.js charts, pass container, width, height directly
                    chartRenderFunctions[chartType](container, width, height);
                } else {
                    chartRenderFunctions[chartType](svg, width, height, defs);
                }
            } else {
                console.error(`Chart type "${chartType}" not found.`);
                const targetSvg = svg || d3.select(container).append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                targetSvg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "20px")
                    .style("fill", "currentColor")
                    .text("Chart type not found.");
            }

            // Populate code snippet
            const codeElement = document.querySelector(`#${chartId}Code code`);
            if (codeElement && chartCodeSnippets[chartType]) {
                codeElement.textContent = chartCodeSnippets[chartType].trim();
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            // Automatically render all charts
            const chartCards = document.querySelectorAll('.chart-card');
            chartCards.forEach((card, index) => {
                const chartId = `chart${index + 1}`;
                const chartType = card.dataset.chartType;
                renderChart(chartId, chartType);
            });
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js"></script>
</head>
<body class="transition-colors duration-300">

    <header class="simplified-header">
        <div class="search-container">
            <i class="fas fa-search search-icon"></i>
            <input type="text" id="mainSearchInput" placeholder="Search charts...">
        </div>
        <button class="dark-mode-toggle ml-4" onclick="toggleDarkMode()">
            <i class="fas fa-moon dark:hidden"></i>
            <i class="fas fa-sun hidden dark:inline-block"></i>
        </button>
    </header>

    <main class="container py-16">
        <h2 class="section-title mb-16 wow animate__animated animate__fadeIn">Interactive Data Visualization Templates</h2>

        <div id="chartCardsContainer" class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <section id="chart1" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.1s" data-chart-type="bar">
                <h2>1. Bar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Compare quantities across different categories.</p>
                <div id="chart1Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart1', 'bar')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart1')">Show Code</button>
                </div>
                <div id="chart1Code" class="code-container"><code></code></div>
            </section>

            <section id="chart2" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.2s" data-chart-type="line">
                <h2>2. Line Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show trends over time or continuous data.</p>
                <div id="chart2Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart2', 'line')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart2')">Show Code</button>
                </div>
                <div id="chart2Code" class="code-container"><code></code></div>
            </section>

            <section id="chart3" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.3s" data-chart-type="pie">
                <h2>3. Pie Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Represent parts of a whole as slices of a circle.</p>
                <div id="chart3Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart3', 'pie')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart3')">Show Code</button>
                </div>
                <div id="chart3Code" class="code-container"><code></code></div>
            </section>

            <section id="chart4" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.4s" data-chart-type="donut">
                <h2>4. Donut Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Similar to pie chart, with a hole in the center for additional info.</p>
                <div id="chart4Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart4', 'donut')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart4')">Show Code</button>
                </div>
                <div id="chart4Code" class="code-container"><code></code></div>
            </section>

            <section id="chart5" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.5s" data-chart-type="area">
                <h2>5. Area Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize the magnitude of change over time.</p>
                <div id="chart5Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart5', 'area')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart5')">Show Code</button>
                </div>
                <div id="chart5Code" class="code-container"><code></code></div>
            </section>

            <section id="chart6" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.6s" data-chart-type="scatter">
                <h2>6. Scatter Plot</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show relationships between two numerical variables.</p>
                <div id="chart6Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart6', 'scatter')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart6')">Show Code</button>
                </div>
                <div id="chart6Code" class="code-container"><code></code></div>
            </section>

            <section id="chart7" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.7s" data-chart-type="bubble">
                <h2>7. Bubble Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize three dimensions of data (X, Y, Size).</p>
                <div id="chart7Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart7', 'bubble')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart7')">Show Code</button>
                </div>
                <div id="chart7Code" class="code-container"><code></code></div>
            </section>

            <section id="chart8" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.8s" data-chart-type="radar">
                <h2>8. Radar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Display multivariate data on a two-dimensional chart.</p>
                <div id="chart8Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart8', 'radar')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart8')">Show Code</button>
                </div>
                <div id="chart8Code" class="code-container"><code></code></div>
            </section>

            <section id="chart9" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="0.9s" data-chart-type="heatmap">
                <h2>9. Heatmap</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize data density or magnitude using color.</p>
                <div id="chart9Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart9', 'heatmap')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart9')">Show Code</button>
                </div>
                <div id="chart9Code" class="code-container"><code></code></div>
            </section>

            <section id="chart10" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.0s" data-chart-type="treemap">
                <h2>10. Treemap</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Display hierarchical data using nested rectangles.</p>
                <div id="chart10Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart10', 'treemap')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart10')">Show Code</button>
                </div>
                <div id="chart10Code" class="code-container"><code></code></div>
            </section>

            <section id="chart11" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.1s" data-chart-type="gauge">
                <h2>11. Gauge Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show progress towards a goal or a single metric's status.</p>
                <div id="chart11Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart11', 'gauge')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart11')">Show Code</button>
                </div>
                <div id="chart11Code" class="code-container"><code></code></div>
            </section>

            <section id="chart12" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.2s" data-chart-type="progress">
                <h2>12. Progress Bar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Illustrate completion rates for various tasks.</p>
                <div id="chart12Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart12', 'progress')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart12')">Show Code</button>
                </div>
                <div id="chart12Code" class="code-container"><code></code></div>
            </section>

            <section id="chart13" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.3s" data-chart-type="stacked-bar">
                <h2>13. Stacked Bar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show composition of categories over time or across groups.</p>
                <div id="chart13Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart13', 'stacked-bar')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart13')">Show Code</button>
                </div>
                <div id="chart13Code" class="code-container"><code></code></div>
            </section>

            <section id="chart14" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.4s" data-chart-type="grouped-bar">
                <h2>14. Grouped Bar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Compare multiple series of data within categories.</p>
                <div id="chart14Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart14', 'grouped-bar')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart14')">Show Code</button>
                </div>
                <div id="chart14Code" class="code-container"><code></code></div>
            </section>

            <section id="chart15" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.5s" data-chart-type="candlestick">
                <h2>15. Candlestick Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Represent price movements over time (Open, High, Low, Close).</p>
                <div id="chart15Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart15', 'candlestick')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart15')">Show Code</button>
                </div>
                <div id="chart15Code" class="code-container"><code></code></div>
            </section>

            <section id="chart16" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.6s" data-chart-type="waterfall">
                <h2>16. Waterfall Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show how an initial value is affected by a series of positive or negative changes.</p>
                <div id="chart16Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart16', 'waterfall')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart16')">Show Code</button>
                </div>
                <div id="chart16Code" class="code-container"><code></code></div>
            </section>

            <section id="chart17" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.7s" data-chart-type="stacked-area">
                <h2>17. Stacked Area Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show how parts of a whole change over time.</p>
                <div id="chart17Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart17', 'stacked-area')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart17')">Show Code</button>
                </div>
                <div id="chart17Code" class="code-container"><code></code></div>
            </section>

            <section id="chart18" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.8s" data-chart-type="radial-bar">
                <h2>18. Radial Bar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Circular bar chart for categorical comparisons.</p>
                <div id="chart18Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart18', 'radial-bar')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart18')">Show Code</button>
                </div>
                <div id="chart18Code" class="code-container"><code></code></div>
            </section>

            <section id="chart19" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="1.9s" data-chart-type="bullet">
                <h2>19. Bullet Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Compare a primary measure to one or more other measures and to a qualitative range.</p>
                <div id="chart19Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart19', 'bullet')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart19')">Show Code</button>
                </div>
                <div id="chart19Code" class="code-container"><code></code></div>
            </section>

            <section id="chart20" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.0s" data-chart-type="box-plot">
                <h2>20. Box Plot (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Display the distribution of data based on a five-number summary.</p>
                <div id="chart20Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart20', 'box-plot')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart20')">Show Code</button>
                </div>
                <div id="chart20Code" class="code-container"><code></code></div>
            </section>

            <section id="chart21" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.1s" data-chart-type="choropleth">
                <h2>21. Choropleth Map (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize geographical data using color intensity.</p>
                <div id="chart21Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart21', 'choropleth')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart21')">Show Code</button>
                </div>
                <div id="chart21Code" class="code-container"><code></code></div>
            </section>

            <section id="chart22" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.2s" data-chart-type="streamgraph">
                <h2>22. Streamgraph (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show changes in data proportions over time with a flowing, organic shape.</p>
                <div id="chart22Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart22', 'streamgraph')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart22')">Show Code</button>
                </div>
                <div id="chart22Code" class="code-container"><code></code></div>
            </section>

            <section id="chart23" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.3s" data-chart-type="tree">
                <h2>23. Tree Diagram (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Represent hierarchical data in a tree-like structure.</p>
                <div id="chart23Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart23', 'tree')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart23')">Show Code</button>
                </div>
                <div id="chart23Code" class="code-container"><code></code></div>
            </section>

            <section id="chart24" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.4s" data-chart-type="word-cloud">
                <h2>24. Word Cloud (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize text data, where word size indicates frequency or importance.</p>
                <div id="chart24Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart24', 'word-cloud')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart24')">Show Code</button>
                </div>
                <div id="chart24Code" class="code-container"><code></code></div>
            </section>

            <section id="chart25" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.5s" data-chart-type="parallel-coordinates">
                <h2>25. Parallel Coordinates (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Plot multivariate data as lines connecting points on parallel axes.</p>
                <div id="chart25Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart25', 'parallel-coordinates')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart25')">Show Code</button>
                </div>
                <div id="chart25Code" class="code-container"><code></code></div>
            </section>

            <section id="chart26" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.6s" data-chart-type="polar-area">
                <h2>26. Polar Area Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Like a pie chart, but segment radius varies with value.</p>
                <div id="chart26Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart26', 'polar-area')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart26')">Show Code</button>
                </div>
                <div id="chart26Code" class="code-container"><code></code></div>
            </section>

            <section id="chart27" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.7s" data-chart-type="funnel">
                <h2>27. Funnel Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Illustrate stages in a process and their conversion rates.</p>
                <div id="chart27Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart27', 'funnel')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart27')">Show Code</button>
                </div>
                <div id="chart27Code" class="code-container"><code></code></div>
            </section>

            <section id="chart28" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.8s" data-chart-type="pyramid">
                <h2>28. Pyramid Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize hierarchical data in a pyramid shape, often for population demographics.</p>
                <div id="chart28Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart28', 'pyramid')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart28')">Show Code</button>
                </div>
                <div id="chart28Code" class="code-container"><code></code></div>
            </section>

            <section id="chart29" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="2.9s" data-chart-type="bullet-list">
                <h2>29. Bullet List Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">A series of bullet charts for multiple performance indicators.</p>
                <div id="chart29Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart29', 'bullet-list')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart29')">Show Code</button>
                </div>
                <div id="chart29Code" class="code-container"><code></code></div>
            </section>

            <section id="chart30" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.0s" data-chart-type="calendar-heatmap">
                <h2>30. Calendar Heatmap (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show daily data patterns over a calendar year using color intensity.</p>
                <div id="chart30Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart30', 'calendar-heatmap')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart30')">Show Code</button>
                </div>
                <div id="chart30Code" class="code-container"><code></code></div>
            </section>

            <section id="chart31" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.1s" data-chart-type="chord-matrix">
                <h2>31. Chord Matrix (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Represent relationships or flows between entities in a matrix format.</p>
                <div id="chart31Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart31', 'chord-matrix')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart31')">Show Code</button>
                </div>
                <div id="chart31Code" class="code-container"><code></code></div>
            </section>

            <section id="chart32" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.2s" data-chart-type="packed-circles">
                <h2>32. Packed Circles (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize hierarchical data as nested circles, with size representing value.</p>
                <div id="chart32Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart32', 'packed-circles')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart32')">Show Code</button>
                </div>
                <div id="chart32Code" class="code-container"><code></code></div>
            </section>

            <section id="chart33" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.3s" data-chart-type="density-plot">
                <h2>33. Density Plot (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Show the distribution of a single numerical variable using a smoothed curve.</p>
                <div id="chart33Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart33', 'density-plot')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart33')">Show Code</button>
                </div>
                <div id="chart33Code" class="code-container"><code></code></div>
            </section>

            <section id="chart34" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.4s" data-chart-type="polar-line">
                <h2>34. Polar Line Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Display data in a circular coordinate system, often for cyclical patterns.</p>
                <div id="chart34Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart34', 'polar-line')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart34')">Show Code</button>
                </div>
                <div id="chart34Code" class="code-container"><code></code></div>
            </section>

            <section id="chart35" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.5s" data-chart-type="gauge-multi">
                <h2>35. Multi-Segment Gauge Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">A gauge chart with multiple colored segments indicating performance zones.</p>
                <div id="chart35Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart35', 'gauge-multi')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart35')">Show Code</button>
                </div>
                <div id="chart35Code" class="code-container"><code></code></div>
            </section>

            <section id="chart36" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.6s" data-chart-type="timeline">
                <h2>36. Timeline Chart (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize a sequence of events or milestones over time.</p>
                <div id="chart36Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart36', 'timeline')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart36')">Show Code</button>
                </div>
                <div id="chart36Code" class="code-container"><code></code></div>
            </section>

            <section id="chart37" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.7s" data-chart-type="chord-simple">
                <h2>37. Simple Chord Diagram</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Illustrate relationships and flows between a set of entities.</p>
                <div id="chart37Chart" class="chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart37', 'chord-simple')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart37')">Show Code</button>
                </div>
                <div id="chart37Code" class="code-container"><code></code></div>
            </section>

            <section id="chart38" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.8s" data-chart-type="3d-bar">
                <h2>38. 3D Bar Chart</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">A three-dimensional representation of a bar chart. Click and drag to rotate.</p>
                <div id="chart38Chart" class="three-chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart38', '3d-bar')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart38')">Show Code</button>
                </div>
                <div id="chart38Code" class="code-container"><code></code></div>
            </section>

            <section id="chart39" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="3.9s" data-chart-type="3d-scatter">
                <h2>39. 3D Scatter Plot</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Visualize relationships between three numerical variables. Click and drag to rotate.</p>
                <div id="chart39Chart" class="three-chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart39', '3d-scatter')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart39')">Show Code</button>
                </div>
                <div id="chart39Code" class="code-container"><code></code></div>
            </section>

            <section id="chart40" class="chart-card wow animate__animated animate__fadeInUp" data-wow-delay="4.0s" data-chart-type="3d-surface">
                <h2>40. 3D Surface Plot (Simplified)</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-4 text-center">Represent a function of two variables as a surface. Click and drag to rotate.</p>
                <div id="chart40Chart" class="three-chart-container"></div>
                <div class="button-group">
                    <button onclick="renderChart('chart40', '3d-surface')">Re-render</button>
                    <button class="toggle-code-button" onclick="toggleCode('chart40')">Show Code</button>
                </div>
                <div id="chart40Code" class="code-container"><code></code></div>
            </section>

        </div>
    </main>

    <div id="messageBoxOverlay" class="message-box-overlay">
        <div class="message-box-content">
            <h3 id="messageBoxTitle" class="text-xl font-bold mb-3"></h3>
            <p id="messageBoxText" class="text-gray-700 dark:text-gray-300"></p>
            <button id="messageBoxButton" class="message-box-button" onclick="closeMessageBox()">OK</button>
        </div>
    </div>

</body>
</html>
