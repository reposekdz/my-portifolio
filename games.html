<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15 Interactive Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light slate background */
            color: #1e293b; /* Dark slate text */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark body {
            background-color: #0f172a; /* Darker slate background */
            color: #e2e8f0; /* Light slate text */
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .section-title {
            font-size: 2.75rem; /* 4xl */
            font-weight: 800; /* Extra bold */
            text-align: center;
            margin-bottom: 1.5rem;
            background: linear-gradient(45deg, #6366f1, #a78bfa); /* Indigo to Purple gradient */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            display: inline-block;
            padding-bottom: 0.5rem;
        }
        .section-title::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
            width: 100px;
            height: 5px;
            background: linear-gradient(90deg, #6366f1, #a78bfa);
            border-radius: 2px;
        }

        .game-card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin-bottom: 3rem;
            transition: all 0.3s ease-in-out;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }
        .dark .game-card {
            background-color: #1e293b;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            border-color: #334155;
        }
        .game-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.15);
        }
        .dark .game-card:hover {
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.4);
        }

        .game-card h2 {
            font-size: 2.25rem; /* 3xl */
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #334155;
            text-align: center;
        }
        .dark .game-card h2 {
            color: #f8fafc;
        }

        .code-preview-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        @media (min-width: 1024px) { /* Large screens */
            .code-preview-container {
                flex-direction: row;
            }
        }

        .code-editor, .live-preview {
            flex: 1;
            border-radius: 1rem;
            overflow: hidden;
            border: 2px solid #cbd5e1; /* Slate 300 */
            transition: border-color 0.3s ease;
        }
        .dark .code-editor, .dark .live-preview {
            border-color: #475569; /* Slate 700 */
        }

        .code-editor textarea {
            width: 100%;
            height: 450px; /* Fixed height for both */
            padding: 1rem;
            background-color: #2d3748; /* Dark code background */
            color: #f8fafc; /* Light text */
            font-family: monospace;
            font-size: 0.9rem;
            border: none;
            outline: none;
            resize: vertical; /* Allow vertical resizing */
            border-radius: 1rem;
        }

        .live-preview iframe {
            width: 100%;
            height: 450px; /* Fixed height for both */
            background-color: #ffffff;
            border: none;
            border-radius: 1rem;
        }
        .dark .live-preview iframe {
            background-color: #0f172a;
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .button-group button {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, #6366f1, #a78bfa);
            color: white;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3);
            border: none;
            cursor: pointer;
        }
        .dark .button-group button {
            background: linear-gradient(45deg, #a78bfa, #8b5cf6);
            box-shadow: 0 5px 15px rgba(167, 139, 250, 0.3);
        }
        .button-group button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }
        .dark .button-group button:hover {
            box-shadow: 0 8px 20px rgba(167, 139, 250, 0.4);
        }

        /* Message Box styles */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher than modals */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .message-box-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .message-box-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .dark .message-box-content {
            background-color: #1e293b;
        }
        .message-box-overlay.open .message-box-content {
            transform: translateY(0);
            opacity: 1;
        }
        .message-box-button {
            background-color: #6366f1;
            color: white;
            padding: 0.6rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            margin-top: 1.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .dark .message-box-button {
            background-color: #a78bfa;
        }
        .message-box-button:hover {
            background-color: #4f46e5;
        }
        .dark .message-box-button:hover {
            background-color: #8b5cf6;
        }
    </style>
    <script>
        // Initialize dark mode preference immediately to prevent FOUC
        if (localStorage.getItem('darkMode') === 'true' ||
            (!('darkMode' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
</head>
<body class="transition-colors duration-300">

    <header class="py-12 bg-gradient-to-r from-green-600 to-teal-700 dark:from-green-800 dark:to-teal-900 text-white text-center shadow-lg">
        <h1 class="text-5xl font-extrabold mb-3 animate__animated animate__fadeInDown">Interactive Games</h1>
        <p class="text-xl font-light animate__animated animate__fadeInUp animate__delay-1s">Dive into fun and engaging browser games!</p>
    </header>

    <main class="container py-16">
        <h2 class="section-title mb-16 wow animate__animated animate__fadeIn">Game Showcase</h2>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.1s">
            <h2>1. Simple Clicker Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game1Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clicker Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1a202c; color: #e2e8f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; overflow: hidden; }
        .game-area {
            background-color: #2d3748;
            border: 5px solid #4a5568;
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            animation: fadeIn 0.8s ease-out;
        }
        .click-button {
            background: linear-gradient(45deg, #ef4444, #f97316);
            color: white;
            padding: 1.5rem 3rem;
            font-size: 2.5rem;
            font-weight: bold;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 15px rgba(249,115,22,0.4);
            border: none;
            outline: none;
            margin-top: 2rem;
            animation: pulse 1s infinite alternate;
        }
        .click-button:active {
            transform: scale(0.95);
            box-shadow: 0 4px 10px rgba(249,115,22,0.6);
        }
        .score-display {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #fbd38d;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="game-area">
        <h1 class="text-4xl mb-4 text-yellow-400">Clicker Game</h1>
        <div class="score-display">Score: <span id="score">0</span></div>
        <button id="clickButton" class="click-button">CLICK ME!</button>
    </div>

    <script>
        let score = 0;
        const scoreElement = document.getElementById('score');
        const clickButton = document.getElementById('clickButton');

        clickButton.addEventListener('click', () => {
            score++;
            scoreElement.textContent = score;
            // Optional: Add a visual effect on click
            clickButton.style.transform = 'scale(0.9)';
            setTimeout(() => {
                clickButton.style.transform = 'scale(1)';
            }, 100);
        });
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game1Preview" title="Clicker Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game1')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.2s">
            <h2>2. Color Guessing Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game2Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Guessing Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Roboto Mono', monospace; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: 450px;
            max-width: 90%;
            animation: slideInUp 0.8s ease-out;
        }
        @keyframes slideInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .color-box {
            width: 150px;
            height: 150px;
            background-color: #ccc;
            margin: 2rem auto;
            border-radius: 1rem;
            border: 4px solid #6b7280;
            transition: background-color 0.5s ease;
        }
        .rgb-display {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #d1d5db;
        }
        .guess-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .guess-button {
            padding: 1rem;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            color: white;
            background: linear-gradient(45deg, #6366f1, #a78bfa);
            box-shadow: 0 4px 10px rgba(99,102,241,0.3);
        }
        .guess-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(99,102,241,0.4);
        }
        .guess-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(99,102,241,0.5);
        }
        .message {
            margin-top: 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: #f8fafc;
        }
        .message.correct { color: #34d399; }
        .message.incorrect { color: #f87171; }
        .new-game-btn {
            margin-top: 2rem;
            background-color: #10b981;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
        }
        .new-game-btn:hover {
            background-color: #059669;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl font-bold mb-4 text-purple-300">Guess the Color!</h1>
        <div id="colorBox" class="color-box"></div>
        <div id="rgbDisplay" class="rgb-display">RGB(?, ?, ?)</div>
        <div id="message" class="message">Click a button to guess!</div>
        <div id="guessButtons" class="guess-grid">
            <button class="guess-button" data-color="0">Guess 1</button>
            <button class="guess-button" data-color="1">Guess 2</button>
            <button class="guess-button" data-color="2">Guess 3</button>
            <button class="guess-button" data-color="3">Guess 4</button>
        </div>
        <button id="newGameBtn" class="new-game-btn">New Game</button>
    </div>

    <script>
        let correctColorRGB;
        let options = [];

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function createNewGame() {
            options = [];
            correctColorRGB = generateRandomColor();
            options.push(correctColorRGB);

            while (options.length < 4) {
                const randomColor = generateRandomColor();
                if (!options.includes(randomColor)) {
                    options.push(randomColor);
                }
            }
            options.sort(() => Math.random() - 0.5); // Shuffle options

            document.getElementById('colorBox').style.backgroundColor = correctColorRGB;
            document.getElementById('rgbDisplay').textContent = correctColorRGB.toUpperCase();
            document.getElementById('message').textContent = 'Click a button to guess!';
            document.getElementById('message').classList.remove('correct', 'incorrect');

            const guessButtons = document.querySelectorAll('.guess-button');
            guessButtons.forEach((button, index) => {
                button.style.backgroundColor = options[index];
                button.textContent = `Guess ${index + 1}`; // Display generic text, color is the clue
                button.disabled = false;
            });
        }

        document.querySelectorAll('.guess-button').forEach(button => {
            button.addEventListener('click', function() {
                const messageElement = document.getElementById('message');
                if (this.style.backgroundColor === correctColorRGB) {
                    messageElement.textContent = 'Correct!';
                    messageElement.classList.add('correct');
                    document.querySelectorAll('.guess-button').forEach(btn => btn.disabled = true);
                } else {
                    messageElement.textContent = 'Incorrect. Try again!';
                    messageElement.classList.add('incorrect');
                }
            });
        });

        document.getElementById('newGameBtn').addEventListener('click', createNewGame);

        createNewGame(); // Start the first game
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game2Preview" title="Color Guessing Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game2')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.3s">
            <h2>3. Whack-a-Mole</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game3Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack-a-Mole</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body { font-family: 'Creepster', cursive; background-color: #4a5568; color: #f8fafc; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 500px;
            max-width: 90%;
        }
        .score-timer {
            display: flex;
            justify-content: space-around;
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: #a78bfa;
        }
        .mole-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }
        .hole {
            width: 100px;
            height: 100px;
            background-color: #6b7280;
            border-radius: 50%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            border: 3px solid #4a5568;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .mole {
            position: absolute;
            width: 80%;
            height: 80%;
            background-color: #ef4444; /* Red mole */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            color: white;
            cursor: pointer;
            transform: translateY(100%); /* Start hidden */
            transition: transform 0.3s ease-out;
            box-shadow: 0 5px 10px rgba(0,0,0,0.3);
        }
        .mole.up {
            transform: translateY(0%);
        }
        .mole.hit {
            background-color: #34d399; /* Green on hit */
            transform: scale(0.8);
        }
        .start-button {
            margin-top: 2rem;
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 2rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-red-400">Whack-a-Mole!</h1>
        <div class="score-timer">
            <div>Score: <span id="score">0</span></div>
            <div>Time: <span id="timer">30</span>s</div>
        </div>
        <div class="mole-grid" id="moleGrid">
            <div class="hole"><div class="mole" data-id="0"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="1"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="2"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="3"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="4"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="5"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="6"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="7"><i class="fas fa-skull"></i></div></div>
            <div class="hole"><div class="mole" data-id="8"><i class="fas fa-skull"></i></div></div>
        </div>
        <button id="startButton" class="start-button">Start Game</button>
    </div>

    <script>
        const moles = document.querySelectorAll('.mole');
        const scoreDisplay = document.getElementById('score');
        const timerDisplay = document.getElementById('timer');
        const startButton = document.getElementById('startButton');

        let score = 0;
        let time = 30;
        let lastMole;
        let timerId;
        let moleTimerId;
        let gameRunning = false;

        function randomMole() {
            const index = Math.floor(Math.random() * moles.length);
            const mole = moles[index];
            if (mole === lastMole) {
                return randomMole(); // Ensure different mole
            }
            lastMole = mole;
            return mole;
        }

        function popUpMole() {
            if (!gameRunning) return;

            moles.forEach(mole => {
                mole.classList.remove('up', 'hit');
            });

            const mole = randomMole();
            mole.classList.add('up');

            const popUpTime = Math.random() * 1000 + 500; // Mole stays up for 0.5s to 1.5s
            moleTimerId = setTimeout(() => {
                mole.classList.remove('up');
                if (gameRunning) popUpMole();
            }, popUpTime);
        }

        function startGame() {
            score = 0;
            time = 30;
            scoreDisplay.textContent = score;
            timerDisplay.textContent = time;
            gameRunning = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';

            popUpMole();
            timerId = setInterval(() => {
                time--;
                timerDisplay.textContent = time;
                if (time <= 0) {
                    clearInterval(timerId);
                    clearTimeout(moleTimerId);
                    gameRunning = false;
                    moles.forEach(mole => mole.classList.remove('up', 'hit'));
                    startButton.disabled = false;
                    startButton.textContent = 'Start Game';
                    parent.showMessageBox(`Game Over! Your score is ${score}`, 'info', 'Game Over');
                }
            }, 1000);
        }

        moles.forEach(mole => {
            mole.addEventListener('click', function() {
                if (!gameRunning || this.classList.contains('hit')) return;
                score++;
                scoreDisplay.textContent = score;
                this.classList.add('hit'); // Mark as hit
                clearTimeout(moleTimerId); // Stop current mole from going down
                setTimeout(() => {
                    this.classList.remove('up', 'hit'); // Hide mole after a short delay
                    if (gameRunning) popUpMole(); // Pop up a new mole immediately
                }, 200);
            });
        });

        startButton.addEventListener('click', startGame);
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game3Preview" title="Whack-a-Mole Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game3')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.4s">
            <h2>4. Memory Card Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game4Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body { font-family: 'Fredoka One', cursive; background: linear-gradient(135deg, #a6c1ee, #fbc2eb); display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            text-align: center;
            width: 600px;
            max-width: 95%;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin: 2rem auto;
            width: fit-content;
        }
        .card {
            width: 100px;
            height: 100px;
            background-color: #6366f1; /* Indigo 500 */
            border-radius: 0.75rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            color: white;
            cursor: pointer;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            box-shadow: 0 5px 15px rgba(99,102,241,0.3);
        }
        .card.flipped {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.75rem;
        }
        .card-front {
            background-color: #6366f1;
            color: white;
        }
        .card-back {
            background-color: #f8fafc;
            color: #1e293b;
            transform: rotateY(180deg);
        }
        .card.matched .card-front, .card.matched .card-back {
            background-color: #34d399; /* Green on match */
            color: white;
        }
        .card.matched {
            pointer-events: none; /* Disable clicks on matched cards */
        }
        .game-info {
            font-size: 1.2rem;
            font-weight: 600;
            color: #334155;
            margin-bottom: 1rem;
        }
        .new-game-btn {
            background: linear-gradient(90deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .new-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-pink-500">Memory Game</h1>
        <div class="game-info">Moves: <span id="moves">0</span></div>
        <div id="gameBoard" class="game-board"></div>
        <button id="newGameBtn" class="new-game-btn">New Game</button>
    </div>

    <script>
        const symbols = ['ðŸŽ', 'ðŸŒ', 'ðŸ’', 'ðŸ‡', 'ðŸ‰', 'ðŸ“', 'ðŸ', 'ðŸ¥'];
        let cards = [];
        let flippedCards = [];
        let matchedPairs = 0;
        let moves = 0;
        let lockBoard = false;

        const gameBoard = document.getElementById('gameBoard');
        const movesDisplay = document.getElementById('moves');
        const newGameBtn = document.getElementById('newGameBtn');

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createBoard() {
            gameBoard.innerHTML = '';
            cards = shuffle([...symbols, ...symbols]); // Duplicate symbols for pairs
            flippedCards = [];
            matchedPairs = 0;
            moves = 0;
            movesDisplay.textContent = moves;
            lockBoard = false;

            cards.forEach((symbol, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.dataset.symbol = symbol;
                cardElement.dataset.index = index;

                cardElement.innerHTML = `
                    <div class="card-front"></div>
                    <div class="card-back">${symbol}</div>
                `;

                cardElement.addEventListener('click', flipCard);
                gameBoard.appendChild(cardElement);
            });
        }

        function flipCard() {
            if (lockBoard) return;
            if (this === flippedCards[0]) return; // Prevent double clicking the same card

            this.classList.add('flipped');
            flippedCards.push(this);

            if (flippedCards.length === 2) {
                moves++;
                movesDisplay.textContent = moves;
                lockBoard = true; // Lock board while checking
                checkForMatch();
            }
        }

        function checkForMatch() {
            const [card1, card2] = flippedCards;
            const isMatch = card1.dataset.symbol === card2.dataset.symbol;

            if (isMatch) {
                matchedPairs++;
                card1.classList.add('matched');
                card2.classList.add('matched');
                resetFlippedCards();
                if (matchedPairs === symbols.length) {
                    setTimeout(() => {
                        parent.showMessageBox(`Congratulations! You won in ${moves} moves!`, 'success', 'Game Won!');
                    }, 500);
                }
            } else {
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                    resetFlippedCards();
                }, 1000); // Flip back after 1 second
            }
        }

        function resetFlippedCards() {
            flippedCards = [];
            lockBoard = false;
        }

        newGameBtn.addEventListener('click', createBoard);

        createBoard(); // Initialize game on load
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game4Preview" title="Memory Card Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game4')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.5s">
            <h2>5. Snake Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game5Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'VT323', monospace; background-color: #2d3748; color: #f8fafc; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #1a202c;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 450px;
            max-width: 90%;
        }
        canvas {
            background-color: #4a5568;
            border: 4px solid #718096;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            display: flex;
            justify-content: space-around;
            font-size: 1.5rem;
            font-weight: bold;
            color: #9f7aea;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-green-400">Snake Game</h1>
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>High Score: <span id="highScore">0</span></div>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        const gridSize = 20;
        let snake = [{ x: 10, y: 10 }];
        let food = {};
        let direction = 'right';
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameInterval;
        let gameSpeed = 150; // Milliseconds per frame
        let gameRunning = false;

        highScoreDisplay.textContent = highScore;

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Draw food
            ctx.fillStyle = '#ef4444'; // Red
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

            // Draw snake
            ctx.fillStyle = '#34d399'; // Green
            snake.forEach(segment => {
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                ctx.strokeStyle = '#10b981'; // Darker green border
                ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            });
        }

        function generateFood() {
            food = {
                x: Math.floor(Math.random() * (canvas.width / gridSize)),
                y: Math.floor(Math.random() * (canvas.height / gridSize))
            };
            // Ensure food doesn't spawn on snake
            for (let i = 0; i < snake.length; i++) {
                if (food.x === snake[i].x && food.y === snake[i].y) {
                    generateFood();
                    return;
                }
            }
        }

        function update() {
            if (!gameRunning) return;

            const head = { x: snake[0].x, y: snake[0].y };

            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            // Check for collision with walls
            if (head.x < 0 || head.x >= canvas.width / gridSize ||
                head.y < 0 || head.y >= canvas.height / gridSize) {
                gameOver();
                return;
            }

            // Check for collision with self
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head); // Add new head

            // Check if food is eaten
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreDisplay.textContent = score;
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.textContent = highScore;
                    localStorage.setItem('snakeHighScore', highScore);
                }
                generateFood();
                // Increase speed slightly
                gameSpeed = Math.max(50, gameSpeed - 5);
                clearInterval(gameInterval);
                gameInterval = setInterval(update, gameSpeed);
            } else {
                snake.pop(); // Remove tail
            }

            draw();
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(gameInterval);
            parent.showMessageBox(`Game Over! Your score: ${score}. High score: ${highScore}`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function resetGame() {
            gameRunning = false;
            clearInterval(gameInterval);
            snake = [{ x: 10, y: 10 }];
            direction = 'right';
            score = 0;
            gameSpeed = 150;
            scoreDisplay.textContent = score;
            generateFood();
            draw();
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameRunning) return;
            resetGame(); // Reset before starting new game
            gameRunning = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            gameInterval = setInterval(update, gameSpeed);
        }

        document.addEventListener('keydown', e => {
            if (!gameRunning) return;
            switch (e.key) {
                case 'ArrowUp': if (direction !== 'down') direction = 'up'; break;
                case 'ArrowDown': if (direction !== 'up') direction = 'down'; break;
                case 'ArrowLeft': if (direction !== 'right') direction = 'left'; break;
                case 'ArrowRight': if (direction !== 'left') direction = 'right'; break;
            }
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault(); // Prevent scrolling
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); // Prevent scrolling
        });

        canvas.addEventListener('touchend', e => {
            if (!gameRunning) return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe
                if (dx > 0 && direction !== 'left') direction = 'right';
                else if (dx < 0 && direction !== 'right') direction = 'left';
            } else { // Vertical swipe
                if (dy > 0 && direction !== 'up') direction = 'down';
                else if (dy < 0 && direction !== 'down') direction = 'up';
            }
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial setup
        generateFood();
        draw();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game5Preview" title="Snake Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game5')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.6s">
            <h2>6. Pong Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game6Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1a202c; color: #e2e8f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 600px;
            max-width: 90%;
        }
        canvas {
            background-color: #4a5568;
            border: 4px solid #718096;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .score-display {
            font-size: 2rem;
            font-weight: bold;
            color: #9f7aea;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-green-400">Pong</h1>
        <div class="score-display">Player 1: <span id="player1Score">0</span> | Player 2: <span id="player2Score">0</span></div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let player1Score = 0;
        let player2Score = 0;
        let gameInterval;
        let gameRunning = false;

        const paddleWidth = 15;
        const paddleHeight = 80;
        let player1Y = (canvas.height - paddleHeight) / 2;
        let player2Y = (canvas.height - paddleHeight) / 2;
        const paddleSpeed = 8;

        const ballSize = 10;
        let ballX = canvas.width / 2;
        let ballY = canvas.height / 2;
        let ballSpeedX = 5;
        let ballSpeedY = 5;

        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
        }

        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2, true);
            ctx.fill();
        }

        function draw() {
            // Background
            drawRect(0, 0, canvas.width, canvas.height, '#4a5568');

            // Net
            for (let i = 0; i < canvas.height; i += 20) {
                drawRect(canvas.width / 2 - 2, i, 4, 10, '#718096');
            }

            // Paddles
            drawRect(0, player1Y, paddleWidth, paddleHeight, '#6366f1');
            drawRect(canvas.width - paddleWidth, player2Y, paddleWidth, paddleHeight, '#a78bfa');

            // Ball
            drawCircle(ballX, ballY, ballSize, '#ef4444');
        }

        function update() {
            if (!gameRunning) return;

            // Move ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // Ball collision with top/bottom walls
            if (ballY - ballSize < 0 || ballY + ballSize > canvas.height) {
                ballSpeedY = -ballSpeedY;
            }

            // Ball collision with paddles or score
            if (ballX - ballSize < paddleWidth) { // Left side (Player 1)
                if (ballY > player1Y && ballY < player1Y + paddleHeight) {
                    ballSpeedX = -ballSpeedX;
                    // Adjust ball speed based on where it hit the paddle
                    let deltaY = ballY - (player1Y + paddleHeight / 2);
                    ballSpeedY = deltaY * 0.2;
                } else {
                    player2Score++;
                    player2ScoreDisplay.textContent = player2Score;
                    resetBall();
                }
            } else if (ballX + ballSize > canvas.width - paddleWidth) { // Right side (Player 2)
                if (ballY > player2Y && ballY < player2Y + paddleHeight) {
                    ballSpeedX = -ballSpeedX;
                    // Adjust ball speed based on where it hit the paddle
                    let deltaY = ballY - (player2Y + paddleHeight / 2);
                    ballSpeedY = deltaY * 0.2;
                } else {
                    player1Score++;
                    player1ScoreDisplay.textContent = player1Score;
                    resetBall();
                }
            }

            // Simple AI for Player 2 (follows the ball)
            if (player2Y + paddleHeight / 2 < ballY - 35) {
                player2Y += paddleSpeed;
            } else if (player2Y + paddleHeight / 2 > ballY + 35) {
                player2Y -= paddleSpeed;
            }
            // Keep AI paddle within bounds
            player2Y = Math.max(0, Math.min(canvas.height - paddleHeight, player2Y));

            draw();
            checkWin();
        }

        function resetBall() {
            ballX = canvas.width / 2;
            ballY = canvas.height / 2;
            ballSpeedX = -ballSpeedX; // Serve to the other side
            ballSpeedY = 5 * (Math.random() > 0.5 ? 1 : -1); // Random vertical direction
        }

        function checkWin() {
            if (player1Score >= 5) {
                gameOver("Player 1 Wins!");
            } else if (player2Score >= 5) {
                gameOver("Player 2 Wins!");
            }
        }

        function gameOver(message) {
            gameRunning = false;
            clearInterval(gameInterval);
            parent.showMessageBox(message, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameRunning) return;
            resetGame(); // Ensure a clean start
            gameRunning = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            gameInterval = setInterval(update, 1000 / 60); // 60 FPS
        }

        function resetGame() {
            player1Score = 0;
            player2Score = 0;
            player1ScoreDisplay.textContent = player1Score;
            player2ScoreDisplay.textContent = player2Score;
            player1Y = (canvas.height - paddleHeight) / 2;
            player2Y = (canvas.height - paddleHeight) / 2;
            resetBall();
            draw();
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
            clearInterval(gameInterval);
            gameRunning = false;
        }

        // Mouse movement for Player 1 paddle
        canvas.addEventListener('mousemove', e => {
            if (!gameRunning) return;
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;
            let mouseY = e.clientY - rect.top - root.scrollTop;
            player1Y = mouseY - paddleHeight / 2;
            // Keep paddle within bounds
            player1Y = Math.max(0, Math.min(canvas.height - paddleHeight, player1Y));
        });

        // Touch movement for Player 1 paddle
        canvas.addEventListener('touchmove', e => {
            if (!gameRunning) return;
            e.preventDefault(); // Prevent scrolling
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;
            let touchY = e.touches[0].clientY - rect.top - root.scrollTop;
            player1Y = touchY - paddleHeight / 2;
            player1Y = Math.max(0, Math.min(canvas.height - paddleHeight, player1Y));
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial draw
        draw();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game6Preview" title="Pong Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game6')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.7s">
            <h2>7. Tic-Tac-Toe</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game7Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Permanent Marker', cursive; background: linear-gradient(135deg, #fefce8, #fef3c7); display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            padding: 2.5rem;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            text-align: center;
            width: 400px;
            max-width: 90%;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            width: 300px;
            height: 300px;
            margin: 1.5rem auto;
            background-color: #cbd5e1;
            border-radius: 0.75rem;
            padding: 0.5rem;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        .cell {
            width: 100%;
            height: 100%;
            background-color: #f8fafc;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            color: #334155;
        }
        .cell:hover:not(.occupied) {
            background-color: #e2e8f0;
            transform: scale(1.02);
        }
        .cell.occupied {
            cursor: not-allowed;
        }
        .cell.x { color: #ef4444; } /* Red for X */
        .cell.o { color: #3b82f6; } /* Blue for O */
        .status-display {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #6366f1;
        }
        .reset-btn {
            background: linear-gradient(90deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-orange-500">Tic-Tac-Toe</h1>
        <div id="status" class="status-display">Player X's Turn</div>
        <div id="gameBoard" class="game-board">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="resetButton" class="reset-btn">Reset Game</button>
    </div>

    <script>
        const cells = document.querySelectorAll('.cell');
        const statusDisplay = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');

        let board = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X';
        let gameActive = true;

        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        function handleCellClick(e) {
            const clickedCell = e.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (board[clickedCellIndex] !== '' || !gameActive) {
                return;
            }

            board[clickedCellIndex] = currentPlayer;
            clickedCell.textContent = currentPlayer;
            clickedCell.classList.add('occupied', currentPlayer.toLowerCase());

            checkResult();
        }

        function checkResult() {
            let roundWon = false;
            for (let i = 0; i < winningConditions.length; i++) {
                const winCondition = winningConditions[i];
                let a = board[winCondition[0]];
                let b = board[winCondition[1]];
                let c = board[winCondition[2]];

                if (a === '' || b === '' || c === '') {
                    continue;
                }
                if (a === b && b === c) {
                    roundWon = true;
                    break;
                }
            }

            if (roundWon) {
                statusDisplay.textContent = `Player ${currentPlayer} Wins!`;
                statusDisplay.style.color = currentPlayer === 'X' ? '#ef4444' : '#3b82f6';
                gameActive = false;
                parent.showMessageBox(`Player ${currentPlayer} Wins!`, 'success', 'Game Over!');
                return;
            }

            let roundDraw = !board.includes('');
            if (roundDraw) {
                statusDisplay.textContent = 'It\'s a Draw!';
                statusDisplay.style.color = '#f97316';
                gameActive = false;
                parent.showMessageBox('It\'s a Draw!', 'info', 'Game Over!');
                return;
            }

            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            statusDisplay.textContent = `Player ${currentPlayer}'s Turn`;
            statusDisplay.style.color = '#6366f1';
        }

        function resetGame() {
            board = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = 'X';
            gameActive = true;
            statusDisplay.textContent = `Player ${currentPlayer}'s Turn`;
            statusDisplay.style.color = '#6366f1';
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('occupied', 'x', 'o');
            });
        }

        cells.forEach(cell => cell.addEventListener('click', handleCellClick));
        resetButton.addEventListener('click', resetGame);
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game7Preview" title="Tic-Tac-Toe Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game7')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.8s">
            <h2>8. Hangman Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game8Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hangman Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #2d3748; color: #f8fafc; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #1a202c;
            border-radius: 1.5rem;
            padding: 2.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 550px;
            max-width: 90%;
        }
        .word-display {
            font-size: 2.5rem;
            letter-spacing: 0.5rem;
            margin-bottom: 2rem;
            color: #fbd38d;
        }
        .guesses-left {
            font-size: 1.2rem;
            color: #a78bfa;
            margin-bottom: 1.5rem;
        }
        .keyboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 0.5rem;
            margin-top: 1.5rem;
        }
        .key-button {
            background-color: #4a5568;
            color: white;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            border: none;
            outline: none;
        }
        .key-button:hover:not(:disabled) {
            background-color: #6366f1;
            transform: translateY(-2px);
        }
        .key-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .key-button.correct { background-color: #34d399; }
        .key-button.incorrect { background-color: #ef4444; }
        .message {
            margin-top: 1.5rem;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f8fafc;
        }
        .new-game-btn {
            margin-top: 2rem;
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .new-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-red-400">Hangman</h1>
        <div id="wordDisplay" class="word-display"></div>
        <div class="guesses-left">Guesses Left: <span id="guessesLeft">6</span></div>
        <div id="message" class="message">Start guessing!</div>
        <div id="keyboard" class="keyboard-grid"></div>
        <button id="newGameBtn" class="new-game-btn">New Game</button>
    </div>

    <script>
        const words = ['JAVASCRIPT', 'PROGRAMMING', 'COMPUTER', 'DEVELOPER', 'TAILWIND', 'HTML', 'CSS'];
        let chosenWord = '';
        let guessedWord = [];
        let guessesLeft = 6;
        let gameActive = false;

        const wordDisplay = document.getElementById('wordDisplay');
        const guessesLeftDisplay = document.getElementById('guessesLeft');
        const messageDisplay = document.getElementById('message');
        const keyboardDiv = document.getElementById('keyboard');
        const newGameBtn = document.getElementById('newGameBtn');

        function initializeGame() {
            chosenWord = words[Math.floor(Math.random() * words.length)];
            guessedWord = Array(chosenWord.length).fill('_');
            guessesLeft = 6;
            gameActive = true;

            wordDisplay.textContent = guessedWord.join(' ');
            guessesLeftDisplay.textContent = guessesLeft;
            messageDisplay.textContent = 'Start guessing!';
            messageDisplay.classList.remove('correct', 'incorrect');

            keyboardDiv.innerHTML = '';
            for (let i = 65; i <= 90; i++) { // ASCII for A-Z
                const char = String.fromCharCode(i);
                const button = document.createElement('button');
                button.classList.add('key-button');
                button.textContent = char;
                button.addEventListener('click', () => handleGuess(char, button));
                keyboardDiv.appendChild(button);
            }
            newGameBtn.disabled = true;
        }

        function handleGuess(char, button) {
            if (!gameActive || button.disabled) return;

            button.disabled = true;
            let correctGuess = false;
            for (let i = 0; i < chosenWord.length; i++) {
                if (chosenWord[i] === char) {
                    guessedWord[i] = char;
                    correctGuess = true;
                }
            }

            wordDisplay.textContent = guessedWord.join(' ');

            if (correctGuess) {
                button.classList.add('correct');
                messageDisplay.textContent = 'Good guess!';
                messageDisplay.classList.remove('incorrect');
                messageDisplay.classList.add('correct');
            } else {
                guessesLeft--;
                guessesLeftDisplay.textContent = guessesLeft;
                button.classList.add('incorrect');
                messageDisplay.textContent = `Wrong! ${guessesLeft} guesses left.`;
                messageDisplay.classList.remove('correct');
                messageDisplay.classList.add('incorrect');
            }

            checkGameEnd();
        }

        function checkGameEnd() {
            if (guessedWord.join('') === chosenWord) {
                messageDisplay.textContent = 'You Win! ðŸŽ‰';
                messageDisplay.classList.remove('incorrect');
                messageDisplay.classList.add('correct');
                gameActive = false;
                disableKeyboard();
                newGameBtn.disabled = false;
                parent.showMessageBox(`You guessed the word: ${chosenWord}!`, 'success', 'You Win!');
            } else if (guessesLeft <= 0) {
                messageDisplay.textContent = `Game Over! The word was: ${chosenWord}`;
                messageDisplay.classList.remove('correct');
                messageDisplay.classList.add('incorrect');
                gameActive = false;
                disableKeyboard();
                newGameBtn.disabled = false;
                parent.showMessageBox(`Game Over! The word was: ${chosenWord}`, 'error', 'You Lose!');
            }
        }

        function disableKeyboard() {
            document.querySelectorAll('.key-button').forEach(button => {
                button.disabled = true;
            });
        }

        newGameBtn.addEventListener('click', initializeGame);

        initializeGame(); // Start the first game on load
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game8Preview" title="Hangman Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game8')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.9s">
            <h2>9. Simple Maze Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game9Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #6b7280;
            border: 5px solid #9ca3af;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            font-size: 1.2rem;
            color: #d1d5db;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Maze Game</h1>
        <div class="game-info">Use arrow keys to move the ball. Reach the green square!</div>
        <canvas id="mazeCanvas" width="400" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        const cellSize = 20;
        const mazeWidth = canvas.width / cellSize;
        const mazeHeight = canvas.height / cellSize;

        let player = { x: 1, y: 1, radius: cellSize / 3 };
        let end = { x: mazeWidth - 2, y: mazeHeight - 2 };
        let gameActive = false;

        // Simple maze layout (1 = wall, 0 = path)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
            [1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1],
            [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1],
            [1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1],
            [1,0,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        function drawMaze() {
            for (let row = 0; row < mazeHeight; row++) {
                for (let col = 0; col < mazeWidth; col++) {
                    if (maze[row][col] === 1) {
                        ctx.fillStyle = '#334155'; // Wall color
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function drawPlayer() {
            ctx.fillStyle = '#fbd38d'; // Player color (orange)
            ctx.beginPath();
            ctx.arc(
                player.x * cellSize + cellSize / 2,
                player.y * cellSize + cellSize / 2,
                player.radius,
                0, Math.PI * 2
            );
            ctx.fill();
        }

        function drawEnd() {
            ctx.fillStyle = '#34d399'; // End point color (green)
            ctx.fillRect(end.x * cellSize, end.y * cellSize, cellSize, cellSize);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function updateGame() {
            clearCanvas();
            drawMaze();
            drawEnd();
            drawPlayer();
        }

        function movePlayer(dx, dy) {
            if (!gameActive) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check boundaries
            if (newX >= 0 && newX < mazeWidth && newY >= 0 && newY < mazeHeight) {
                // Check for wall collision
                if (maze[newY][newX] === 0) {
                    player.x = newX;
                    player.y = newY;
                    updateGame();

                    // Check for win condition
                    if (player.x === end.x && player.y === end.y) {
                        gameActive = false;
                        parent.showMessageBox('You reached the end! Congratulations!', 'success', 'You Win!');
                        startButton.disabled = false;
                        startButton.textContent = 'Start Game';
                    }
                }
            }
        }

        function resetGame() {
            player = { x: 1, y: 1, radius: cellSize / 3 };
            gameActive = false;
            updateGame();
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return;
            resetGame(); // Reset position before starting
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            updateGame();
        }

        document.addEventListener('keydown', e => {
            if (!gameActive) return;
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
            }
        });

        // Touch controls for the maze game
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault(); // Prevent scrolling
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); // Prevent scrolling
        });

        canvas.addEventListener('touchend', e => {
            if (!gameActive) return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            const sensitivity = 20; // Adjust sensitivity for swipe detection

            if (Math.abs(dx) > Math.abs(dy)) { // Horizontal swipe
                if (dx > sensitivity) movePlayer(1, 0); // Swipe right
                else if (dx < -sensitivity) movePlayer(-1, 0); // Swipe left
            } else { // Vertical swipe
                if (dy > sensitivity) movePlayer(0, 1); // Swipe down
                else if (dy < -sensitivity) movePlayer(0, -1); // Swipe up
            }
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial draw
        updateGame();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game9Preview" title="Maze Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game9')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="1.0s">
            <h2>10. Typing Speed Test</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game10Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Speed Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Fira Code', monospace; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: 600px;
            max-width: 90%;
        }
        .quote-display {
            background-color: #4b5563;
            color: #d1d5db;
            padding: 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 2rem;
            text-align: left;
        }
        .quote-display .correct { color: #34d399; }
        .quote-display .incorrect { background-color: #ef4444; color: white; border-radius: 0.25rem; padding: 0 2px; }
        .text-input {
            width: 100%;
            padding: 1rem;
            border-radius: 0.75rem;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: #f9fafb;
            font-size: 1.1rem;
            outline: none;
            transition: border-color 0.2s ease;
        }
        .text-input:focus {
            border-color: #6366f1;
        }
        .info-display {
            display: flex;
            justify-content: space-around;
            margin-top: 1.5rem;
            font-size: 1.2rem;
            color: #a78bfa;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-green-400">Typing Speed Test</h1>
        <div id="quoteDisplay" class="quote-display"></div>
        <textarea id="textInput" class="text-input" placeholder="Start typing here..." rows="5" disabled></textarea>
        <div class="info-display">
            <div>Time: <span id="timer">0s</span></div>
            <div>WPM: <span id="wpm">0</span></div>
            <div>Accuracy: <span id="accuracy">100%</span></div>
        </div>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Test</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const quotes = [
            "The quick brown fox jumps over the lazy dog.",
            "Never underestimate the power of a good book.",
            "Innovation distinguishes between a leader and a follower.",
            "The only way to do great work is to love what you do.",
            "Programming is thinking, not typing."
        ];

        let currentQuote = '';
        let timer = 0;
        let intervalId;
        let startTime;
        let gameActive = false;

        const quoteDisplay = document.getElementById('quoteDisplay');
        const textInput = document.getElementById('textInput');
        const timerDisplay = document.getElementById('timer');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        function getRandomQuote() {
            return quotes[Math.floor(Math.random() * quotes.length)];
        }

        function renderNewQuote() {
            currentQuote = getRandomQuote();
            quoteDisplay.innerHTML = '';
            currentQuote.split('').forEach(char => {
                const span = document.createElement('span');
                span.textContent = char;
                quoteDisplay.appendChild(span);
            });
            textInput.value = '';
            textInput.disabled = false;
            textInput.focus();
            timer = 0;
            timerDisplay.textContent = '0s';
            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '100%';
        }

        function startTimer() {
            startTime = new Date().getTime();
            intervalId = setInterval(() => {
                timer = Math.floor((new Date().getTime() - startTime) / 1000);
                timerDisplay.textContent = `${timer}s`;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(intervalId);
        }

        function calculateWPM() {
            const wordsTyped = textInput.value.split(/\s+/).filter(word => word !== '').length;
            if (timer === 0) return 0;
            return Math.round((wordsTyped / timer) * 60);
        }

        function calculateAccuracy() {
            const typedText = textInput.value;
            let correctChars = 0;
            for (let i = 0; i < typedText.length; i++) {
                if (typedText[i] === currentQuote[i]) {
                    correctChars++;
                }
            }
            if (typedText.length === 0) return 100;
            return Math.round((correctChars / typedText.length) * 100);
        }

        function resetGame() {
            stopTimer();
            gameActive = false;
            textInput.disabled = true;
            startButton.disabled = false;
            startButton.textContent = 'Start Test';
            renderNewQuote();
        }

        textInput.addEventListener('input', () => {
            if (!gameActive) {
                gameActive = true;
                startTimer();
            }

            const typedChars = textInput.value.split('');
            const quoteSpans = quoteDisplay.querySelectorAll('span');

            let correctCount = 0;
            quoteSpans.forEach((charSpan, index) => {
                const char = typedChars[index];

                if (char == null) {
                    charSpan.classList.remove('correct', 'incorrect');
                } else if (char === charSpan.textContent) {
                    charSpan.classList.add('correct');
                    charSpan.classList.remove('incorrect');
                    correctCount++;
                } else {
                    charSpan.classList.add('incorrect');
                    charSpan.classList.remove('correct');
                }
            });

            wpmDisplay.textContent = calculateWPM();
            accuracyDisplay.textContent = `${calculateAccuracy()}%`;

            if (typedChars.length === currentQuote.length && calculateAccuracy() === 100) {
                stopTimer();
                gameActive = false;
                textInput.disabled = true;
                startButton.disabled = false;
                startButton.textContent = 'Test Completed!';
                parent.showMessageBox(`Test completed! Your WPM: ${calculateWPM()}, Accuracy: ${calculateAccuracy()}%`, 'success', 'Test Complete!');
            }
        });

        startButton.addEventListener('click', () => {
            if (!gameActive) {
                startButton.disabled = true;
                startButton.textContent = 'Typing...';
                renderNewQuote();
                startTimer();
            }
        });

        resetButton.addEventListener('click', resetGame);

        // Initial setup
        renderNewQuote();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game10Preview" title="Typing Speed Test Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game10')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.1s">
            <h2>11. Catch the Falling Objects</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game11Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catching Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #6b7280;
            border: 5px solid #9ca3af;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            display: flex;
            justify-content: space-around;
            font-size: 1.2rem;
            color: #d1d5db;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Catching Game</h1>
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
        </div>
        <canvas id="gameCanvas" width="500" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let score = 0;
        let lives = 3;
        let player = { x: canvas.width / 2 - 30, y: canvas.height - 40, width: 60, height: 20 };
        let fallingObjects = [];
        let gameInterval;
        let objectSpawnInterval;
        let gameActive = false;

        const objectTypes = [
            { type: 'good', color: '#34d399', value: 10, icon: 'star' },
            { type: 'bad', color: '#ef4444', value: -1, icon: 'skull' }
        ];

        function drawPlayer() {
            ctx.fillStyle = '#6366f1'; // Player color (indigo)
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 2;
            ctx.strokeRect(player.x, player.y, player.width, player.height);
        }

        function drawObject(obj) {
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
            ctx.fill();
            // Optional: Draw icon if available
            if (obj.icon) {
                ctx.font = `${obj.radius * 1.5}px "Font Awesome 6 Free"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(obj.icon === 'star' ? '\uf005' : '\uf54a', obj.x, obj.y); // FontAwesome unicode
            }
        }

        function generateObject() {
            if (!gameActive) return;
            const type = Math.random() < 0.8 ? 'good' : 'bad'; // 80% good, 20% bad
            const objType = objectTypes.find(ot => ot.type === type);
            const radius = 15;
            fallingObjects.push({
                x: Math.random() * (canvas.width - radius * 2) + radius,
                y: -radius, // Start above canvas
                radius: radius,
                speed: Math.random() * 2 + 1, // Speed between 1 and 3
                color: objType.color,
                value: objType.value,
                icon: objType.icon
            });
        }

        function updateGame() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();

            for (let i = 0; i < fallingObjects.length; i++) {
                const obj = fallingObjects[i];
                obj.y += obj.speed;
                drawObject(obj);

                // Check for collision with player
                if (obj.y + obj.radius > player.y &&
                    obj.x - obj.radius < player.x + player.width &&
                    obj.x + obj.radius > player.x &&
                    obj.y - obj.radius < player.y + player.height) {
                    
                    score += obj.value;
                    if (obj.type === 'bad') {
                        lives--;
                        parent.showMessageBox('You caught a bad object! -1 life!', 'error', 'Oops!');
                    } else {
                        parent.showMessageBox('Good catch! +10 points!', 'success', 'Great!');
                    }
                    scoreDisplay.textContent = score;
                    livesDisplay.textContent = lives;
                    fallingObjects.splice(i, 1); // Remove caught object
                    i--; // Adjust index after removal
                } else if (obj.y - obj.radius > canvas.height) {
                    // Object missed
                    if (obj.type === 'good') { // Only lose life if a good object is missed
                        lives--;
                        parent.showMessageBox('You missed a good object! -1 life!', 'error', 'Missed!');
                    }
                    livesDisplay.textContent = lives;
                    fallingObjects.splice(i, 1); // Remove missed object
                    i--;
                }
            }

            if (lives <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameActive = false;
            clearInterval(gameInterval);
            clearInterval(objectSpawnInterval);
            parent.showMessageBox(`Game Over! Your score: ${score}`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function resetGame() {
            score = 0;
            lives = 3;
            player.x = canvas.width / 2 - 30;
            fallingObjects = [];
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            gameActive = false;
            clearInterval(gameInterval);
            clearInterval(objectSpawnInterval);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return;
            resetGame(); // Ensure a clean start
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            gameInterval = setInterval(updateGame, 1000 / 60); // 60 FPS
            objectSpawnInterval = setInterval(generateObject, 1000); // Spawn new object every second
        }

        // Mouse movement for player
        canvas.addEventListener('mousemove', e => {
            if (!gameActive) return;
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;
            let mouseX = e.clientX - rect.left - root.scrollLeft;
            player.x = mouseX - player.width / 2;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        });

        // Touch movement for player
        canvas.addEventListener('touchmove', e => {
            if (!gameActive) return;
            e.preventDefault(); // Prevent scrolling
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;
            let touchX = e.touches[0].clientX - rect.left - root.scrollLeft;
            player.x = touchX - player.width / 2;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial draw
        drawPlayer();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game11Preview" title="Catching Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game11')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.2s">
            <h2>12. Asteroids Game</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game12Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #0f172a; color: #e2e8f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #1a202c;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #0f172a;
            border: 5px solid #475569;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            display: flex;
            justify-content: space-around;
            font-size: 1.2rem;
            color: #94a3b8;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Asteroids</h1>
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let score = 0;
        let lives = 3;
        let gameInterval;
        let gameActive = false;

        // Player (spaceship)
        let player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 20,
            angle: 0,
            speed: 0,
            rotationSpeed: 0,
            thrust: 0.05,
            maxSpeed: 5,
            friction: 0.98,
            bullets: []
        };

        // Asteroids
        let asteroids = [];
        const asteroidMinSize = 20;
        const asteroidMaxSize = 60;
        const asteroidSpeed = 1;

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            ctx.fillStyle = '#3b82f6'; // Blue
            ctx.beginPath();
            ctx.moveTo(0, -player.size);
            ctx.lineTo(-player.size * 0.75, player.size);
            ctx.lineTo(player.size * 0.75, player.size);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function drawAsteroid(asteroid) {
            ctx.strokeStyle = '#cbd5e1'; // Light gray
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Simple polygon for asteroid shape
            const numPoints = Math.floor(Math.random() * 5) + 5; // 5 to 9 points
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const radius = asteroid.size * (0.8 + Math.random() * 0.4); // Irregular shape
                const x = asteroid.x + radius * Math.cos(angle);
                const y = asteroid.y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        function drawBullet(bullet) {
            ctx.fillStyle = '#fbd38d'; // Orange
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function updatePlayer() {
            // Apply thrust
            player.speed += player.thrust * Math.cos(player.angle - Math.PI / 2);
            player.x += player.speed * Math.sin(player.angle);
            player.y -= player.speed * Math.cos(player.angle);

            // Apply friction
            player.speed *= player.friction;

            // Apply rotation
            player.angle += player.rotationSpeed;

            // Wrap around screen
            if (player.x < 0) player.x = canvas.width;
            if (player.x > canvas.width) player.x = 0;
            if (player.y < 0) player.y = canvas.height;
            if (player.y > canvas.height) player.y = 0;
        }

        function updateAsteroids() {
            for (let i = 0; i < asteroids.length; i++) {
                const asteroid = asteroids[i];
                asteroid.x += asteroid.speedX;
                asteroid.y += asteroid.speedY;

                // Wrap around screen
                if (asteroid.x - asteroid.size > canvas.width) asteroid.x = -asteroid.size;
                if (asteroid.x + asteroid.size < 0) asteroid.x = canvas.width + asteroid.size;
                if (asteroid.y - asteroid.size > canvas.height) asteroid.y = -asteroid.size;
                if (asteroid.y + asteroid.size < 0) asteroid.y = canvas.height + asteroid.size;
            }
        }

        function updateBullets() {
            for (let i = 0; i < player.bullets.length; i++) {
                const bullet = player.bullets[i];
                bullet.x += bullet.speedX;
                bullet.y += bullet.speedY;

                // Remove bullets off screen
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                    player.bullets.splice(i, 1);
                    i--;
                }
            }
        }

        function checkCollisions() {
            // Player-Asteroid collisions
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                const dist = Math.sqrt(Math.pow(player.x - asteroid.x, 2) + Math.pow(player.y - asteroid.y, 2));
                if (dist < player.size + asteroid.size * 0.75) { // Collision detected
                    lives--;
                    livesDisplay.textContent = lives;
                    asteroids.splice(i, 1); // Remove asteroid
                    spawnAsteroids(1); // Replace it
                    player.x = canvas.width / 2; // Reset player position
                    player.y = canvas.height / 2;
                    player.speed = 0;
                    player.rotationSpeed = 0;
                    if (lives <= 0) {
                        gameOver();
                        return;
                    }
                    parent.showMessageBox('Hit by asteroid! -1 life!', 'error', 'Collision!');
                }
            }

            // Bullet-Asteroid collisions
            for (let i = player.bullets.length - 1; i >= 0; i--) {
                const bullet = player.bullets[i];
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const asteroid = asteroids[j];
                    const dist = Math.sqrt(Math.pow(bullet.x - asteroid.x, 2) + Math.pow(bullet.y - asteroid.y, 2));
                    if (dist < asteroid.size) { // Collision detected
                        score += 10;
                        scoreDisplay.textContent = score;
                        player.bullets.splice(i, 1); // Remove bullet
                        asteroids.splice(j, 1); // Remove asteroid
                        i--; // Adjust bullet index
                        
                        // Spawn smaller asteroids if large enough
                        if (asteroid.size > asteroidMinSize * 1.5) {
                            spawnAsteroids(2, asteroid.x, asteroid.y, asteroid.size / 2);
                        }
                        parent.showMessageBox('Asteroid hit! +10 points!', 'success', 'Hit!');
                        break; // Break from inner loop as bullet is gone
                    }
                }
            }
        }

        function spawnAsteroids(count, x = null, y = null, size = null) {
            for (let i = 0; i < count; i++) {
                const newSize = size || (Math.random() * (asteroidMaxSize - asteroidMinSize) + asteroidMinSize);
                const newX = x || Math.random() * canvas.width;
                const newY = y || Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                asteroids.push({
                    x: newX,
                    y: newY,
                    size: newSize,
                    speedX: asteroidSpeed * Math.cos(angle),
                    speedY: asteroidSpeed * Math.sin(angle)
                });
            }
        }

        function shootBullet() {
            if (!gameActive) return;
            const bulletSpeed = 10;
            player.bullets.push({
                x: player.x,
                y: player.y,
                speedX: bulletSpeed * Math.sin(player.angle),
                speedY: -bulletSpeed * Math.cos(player.angle)
            });
        }

        function gameLoop() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            updatePlayer();
            updateAsteroids();
            updateBullets();
            checkCollisions();

            drawPlayer();
            asteroids.forEach(drawAsteroid);
            player.bullets.forEach(drawBullet);

            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            parent.showMessageBox(`Game Over! Your score: ${score}`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function resetGame() {
            score = 0;
            lives = 3;
            player = {
                x: canvas.width / 2, y: canvas.height / 2, size: 20, angle: 0, speed: 0, rotationSpeed: 0,
                thrust: 0.05, maxSpeed: 5, friction: 0.98, bullets: []
            };
            asteroids = [];
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            gameActive = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return;
            resetGame(); // Ensure a clean start
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            spawnAsteroids(5); // Start with 5 asteroids
            gameLoop();
        }

        document.addEventListener('keydown', e => {
            if (!gameActive) return;
            switch (e.key) {
                case 'ArrowUp': player.speed += player.thrust; break;
                case 'ArrowLeft': player.rotationSpeed = -0.05; break;
                case 'ArrowRight': player.rotationSpeed = 0.05; break;
                case ' ': shootBullet(); break; // Spacebar to shoot
            }
        });

        document.addEventListener('keyup', e => {
            if (!gameActive) return;
            switch (e.key) {
                case 'ArrowLeft':
                case 'ArrowRight': player.rotationSpeed = 0; break;
            }
        });

        // Touch controls for movement and shooting
        let touchMoveInterval;
        let touchShootTimeout;

        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); // Prevent scrolling and zooming
            if (!gameActive) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // Determine if it's a movement touch or shoot touch
            // Simple logic: left half of screen for movement, right half for shoot
            if (touchX < canvas.width / 2) {
                // Movement: Determine direction based on touch position relative to player
                const dx = touchX - player.x;
                const dy = touchY - player.y;
                player.angle = Math.atan2(dx, -dy); // Point player towards touch

                // Apply thrust while touching
                touchMoveInterval = setInterval(() => {
                    if (gameActive) {
                        player.speed += player.thrust;
                        player.speed = Math.min(player.maxSpeed, player.speed); // Cap speed
                    }
                }, 50);
            } else {
                // Shoot: Trigger shooting
                shootBullet();
                // Prevent rapid firing
                touchShootTimeout = setTimeout(() => {
                    // Re-enable shooting if needed, or implement a cooldown
                }, 200);
            }
        });

        canvas.addEventListener('touchend', e => {
            if (!gameActive) return;
            clearInterval(touchMoveInterval); // Stop movement thrust
            player.speed = 0; // Stop movement
            player.rotationSpeed = 0; // Stop rotation
            clearTimeout(touchShootTimeout);
        });

        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial draw
        drawPlayer();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game12Preview" title="Asteroids Game Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game12')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.3s">
            <h2>13. 3D Cube Rotation</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game13Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Orbitron', sans-serif; background-color: #0f172a; color: #e2e8f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #1a202c;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            display: block;
            margin: 1.5rem auto;
            border: 5px solid #475569;
            border-radius: 0.75rem;
        }
        .info-text {
            font-size: 1rem;
            color: #94a3b8;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-green-400">3D Cube</h1>
        <div class="info-text">Drag your mouse or swipe to rotate the cube!</div>
        <canvas id="threeJsCanvas" width="400" height="400"></canvas>
        <div class="game-buttons">
            <button id="resetViewBtn" class="game-btn">Reset View</button>
        </div>
    </div>

    <script>
        let scene, camera, renderer, cube;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function init() {
            const canvas = document.getElementById('threeJsCanvas');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); // Dark background

            // Camera
            camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
            camera.position.z = 2;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Cube
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({ color: 0x6366f1 }); // Indigo
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // Add edges for better visibility
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x9f7aea, linewidth: 2 })); // Purple outline
            cube.add(line);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Event Listeners for mouse interaction
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('mousemove', onMouseMove, false);

            // Event Listeners for touch interaction
            canvas.addEventListener('touchstart', onTouchStart, false);
            canvas.addEventListener('touchend', onTouchEnd, false);
            canvas.addEventListener('touchmove', onTouchMove, false);

            // Reset button
            document.getElementById('resetViewBtn').addEventListener('click', resetView);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            const canvas = document.getElementById('threeJsCanvas');
            camera.aspect = canvas.width / canvas.height;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.width, canvas.height);
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            cube.rotation.y += deltaX * 0.01;
            cube.rotation.x += deltaY * 0.01;

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onTouchStart(event) {
            event.preventDefault(); // Prevent scrolling
            isDragging = true;
            previousMousePosition.x = event.touches[0].clientX;
            previousMousePosition.y = event.touches[0].clientY;
        }

        function onTouchEnd(event) {
            isDragging = false;
        }

        function onTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (!isDragging) return;

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;

            cube.rotation.y += deltaX * 0.01;
            cube.rotation.x += deltaY * 0.01;

            previousMousePosition.x = event.touches[0].clientX;
            previousMousePosition.y = event.touches[0].clientY;
        }

        function resetView() {
            cube.rotation.x = 0;
            cube.rotation.y = 0;
            cube.rotation.z = 0;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game13Preview" title="3D Cube Rotation Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game13')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.4s">
            <h2>14. Physics Simulation</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game14Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Sim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Orbitron', sans-serif; background-color: #0f172a; color: #e2e8f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #1a202c;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            display: block;
            margin: 1.5rem auto;
            border: 5px solid #475569;
            border-radius: 0.75rem;
        }
        .info-text {
            font-size: 1rem;
            color: #94a3b8;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-green-400">Physics Box</h1>
        <div class="info-text">Click or tap to add balls!</div>
        <canvas id="physicsCanvas" width="500" height="400"></canvas>
        <div class="game-buttons">
            <button id="addBallBtn" class="game-btn">Add Ball</button>
            <button id="resetSimBtn" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let world;
        let meshes = []; // Three.js meshes
        let bodies = []; // Cannon.js bodies

        const timeStep = 1 / 60; // seconds

        function init() {
            const canvas = document.getElementById('physicsCanvas');

            // Three.js setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); // Dark background
            camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 100);
            camera.position.z = 10;
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Cannon.js setup
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // m/sÂ²

            // Create a ground plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 }); // mass = 0 makes it static
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be horizontal
            world.addBody(groundBody);

            // Create walls (simple box for containment)
            const wallThickness = 0.5;
            const boxSize = 5; // Size of the inner box where balls will bounce
            const wallMaterial = new CANNON.Material();

            // Bottom wall (already handled by ground)
            // Top wall
            const topWallBody = new CANNON.Body({ mass: 0 });
            topWallBody.addShape(new CANNON.Plane());
            topWallBody.position.set(0, boxSize / 2, 0);
            topWallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
            world.addBody(topWallBody);

            // Left wall
            const leftWallBody = new CANNON.Body({ mass: 0 });
            leftWallBody.addShape(new CANNON.Plane());
            leftWallBody.position.set(-boxSize / 2, 0, 0);
            topWallBody.ququaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 2);
            world.addBody(leftWallBody);

            // Right wall
            const rightWallBody = new CANNON.Body({ mass: 0 });
            rightWallBody.addShape(new CANNON.Plane());
            rightWallBody.position.set(boxSize / 2, 0, 0);
            rightWallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
            world.addBody(rightWallBody);

            // Back wall (for 3D effect)
            const backWallBody = new CANNON.Body({ mass: 0 });
            backWallBody.addShape(new CANNON.Plane());
            backWallBody.position.set(0, 0, -boxSize / 2);
            world.addBody(backWallBody);

            // Front wall (for 3D effect)
            const frontWallBody = new CANNON.Body({ mass: 0 });
            frontWallBody.addShape(new CANNON.Plane());
            frontWallBody.position.set(0, 0, boxSize / 2);
            frontWallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
            world.addBody(frontWallBody);


            // Add light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Event listeners
            document.getElementById('addBallBtn').addEventListener('click', addBall);
            document.getElementById('resetSimBtn').addEventListener('click', resetSimulation);
            canvas.addEventListener('click', addBallAtClick);
        }

        function addBall(x = null, y = null) {
            const radius = 0.5 + Math.random() * 0.5; // Random size
            const color = new THREE.Color(Math.random(), Math.random(), Math.random());

            // Three.js Mesh
            const sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: color });
            const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphereMesh);
            meshes.push(sphereMesh);

            // Cannon.js Body
            const sphereShape = new CANNON.Sphere(radius);
            const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape });
            sphereBody.position.set(x !== null ? x : (Math.random() - 0.5) * 4, y !== null ? y : (Math.random() * 3) + 2, (Math.random() - 0.5) * 4);
            world.addBody(sphereBody);
            bodies.push(sphereBody);
        }

        function addBallAtClick(event) {
            const canvas = document.getElementById('physicsCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Convert mouse coordinates to Three.js world coordinates
            const vector = new THREE.Vector3(
                (mouseX / canvas.width) * 2 - 1,
                -(mouseY / canvas.height) * 2 + 1,
                0.5 // Z-depth for raycasting
            );
            vector.unproject(camera);

            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            // Add ball at the calculated world position, slightly above to fall
            addBall(pos.x, pos.y + 1);
        }


        function animate() {
            requestAnimationFrame(animate);

            world.step(timeStep); // Update physics world

            // Sync Three.js meshes with Cannon.js bodies
            for (let i = 0; i < meshes.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }

            renderer.render(scene, camera);
        }

        function resetSimulation() {
            // Remove all balls
            for (let i = 0; i < meshes.length; i++) {
                scene.remove(meshes[i]);
            }
            for (let i = 0; i < bodies.length; i++) {
                world.removeBody(bodies[i]);
            }
            meshes = [];
            bodies = [];
        }

        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game14Preview" title="Physics Simulation Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game14')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.5s">
            <h2>15. Drag and Drop Puzzle</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game15Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Fredoka One', cursive; background: linear-gradient(135deg, #fefce8, #fef3c7); display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            text-align: center;
            width: 600px;
            max-width: 95%;
        }
        .puzzle-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            width: 300px;
            height: 300px;
            margin: 1.5rem auto;
            border: 3px solid #cbd5e1;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        .puzzle-piece {
            width: 100%;
            height: 100%;
            background-size: 300% 300%; /* For 3x3 grid */
            border: 1px solid rgba(0,0,0,0.1);
            cursor: grab;
            transition: transform 0.1s ease-out;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .puzzle-piece:active {
            cursor: grabbing;
            z-index: 10; /* Bring dragged piece to front */
        }
        .puzzle-piece.dragging {
            opacity: 0.7;
            transform: scale(1.05);
        }
        .puzzle-piece.correct {
            border: 2px solid #34d399; /* Green border for correct placement */
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-500">Image Puzzle</h1>
        <div id="puzzleBoard" class="puzzle-board"></div>
        <div class="game-buttons">
            <button id="startGameBtn" class="game-btn">Start Game</button>
            <button id="resetGameBtn" class="game-btn red">Reset</button>
        </div>
    </div>

    <script>
        const puzzleBoard = document.getElementById('puzzleBoard');
        const startGameBtn = document.getElementById('startGameBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');

        const imageUrl = 'https://placehold.co/300x300/6366f1/ffffff?text=Puzzle'; // Placeholder image
        const pieces = 9; // 3x3 puzzle
        let puzzleOrder = [];
        let draggedItem = null;
        let gameActive = false;

        function createPuzzle() {
            puzzleBoard.innerHTML = '';
            puzzleOrder = Array.from({ length: pieces }, (_, i) => i); // [0, 1, ..., 8]

            // Shuffle the order for the initial display
            shuffleArray(puzzleOrder);

            puzzleOrder.forEach((originalIndex, displayIndex) => {
                const piece = document.createElement('div');
                piece.classList.add('puzzle-piece');
                piece.draggable = true;
                piece.dataset.originalIndex = originalIndex;
                piece.dataset.currentIndex = displayIndex; // Store current position

                // Calculate background position for each piece
                const row = Math.floor(originalIndex / 3);
                const col = originalIndex % 3;
                piece.style.backgroundImage = `url(${imageUrl})`;
                piece.style.backgroundPosition = `${(col * 100 / 2)}% ${(row * 100 / 2)}%`; // For 3x3, need 300% / (3-1) = 150% steps, so 100%/2
                piece.style.backgroundSize = '300% 300%';

                piece.addEventListener('dragstart', dragStart);
                piece.addEventListener('dragover', dragOver);
                piece.addEventListener('drop', drop);
                piece.addEventListener('dragend', dragEnd);

                puzzleBoard.appendChild(piece);
            });
            checkWin(); // Check initial state (should be false)
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function dragStart(e) {
            if (!gameActive) {
                e.preventDefault();
                return;
            }
            draggedItem = this;
            setTimeout(() => this.classList.add('dragging'), 0);
            e.dataTransfer.effectAllowed = 'move';
        }

        function dragOver(e) {
            e.preventDefault(); // Allow drop
            if (this !== draggedItem && this.classList.contains('puzzle-piece')) {
                e.dataTransfer.dropEffect = 'move';
            } else {
                e.dataTransfer.dropEffect = 'none';
            }
        }

        function drop(e) {
            e.preventDefault();
            if (this === draggedItem || !this.classList.contains('puzzle-piece')) {
                return;
            }

            const targetItem = this;
            const draggedOriginalIndex = parseInt(draggedItem.dataset.originalIndex);
            const targetOriginalIndex = parseInt(targetItem.dataset.originalIndex);

            const draggedCurrentIndex = parseInt(draggedItem.dataset.currentIndex);
            const targetCurrentIndex = parseInt(targetItem.dataset.currentIndex);

            // Swap the elements in the DOM
            const parent = puzzleBoard;
            const draggedNode = parent.children[draggedCurrentIndex];
            const targetNode = parent.children[targetCurrentIndex];

            if (draggedCurrentIndex < targetCurrentIndex) {
                parent.insertBefore(targetNode, draggedNode);
                parent.insertBefore(draggedNode, targetNode.nextSibling);
            } else {
                parent.insertBefore(draggedNode, targetNode);
                parent.insertBefore(targetNode, draggedNode.nextSibling);
            }

            // Update currentIndex data attributes for all pieces
            Array.from(puzzleBoard.children).forEach((piece, index) => {
                piece.dataset.currentIndex = index;
            });

            checkWin();
        }

        function dragEnd() {
            this.classList.remove('dragging');
            draggedItem = null;
        }

        function checkWin() {
            let isSolved = true;
            Array.from(puzzleBoard.children).forEach((piece, index) => {
                if (parseInt(piece.dataset.originalIndex) !== index) {
                    isSolved = false;
                }
                // Add/remove correct class for visual feedback
                if (parseInt(piece.dataset.originalIndex) === index) {
                    piece.classList.add('correct');
                } else {
                    piece.classList.remove('correct');
                }
            });

            if (isSolved && gameActive) {
                gameActive = false;
                parent.showMessageBox('Puzzle Solved! Congratulations!', 'success', 'You Win!');
                startGameBtn.disabled = false;
                startGameBtn.textContent = 'Start Game';
            }
        }

        function startGame() {
            if (gameActive) return;
            gameActive = true;
            startGameBtn.disabled = true;
            startGameBtn.textContent = 'Playing...';
            createPuzzle();
        }

        function resetGame() {
            gameActive = false;
            startGameBtn.disabled = false;
            startGameBtn.textContent = 'Start Game';
            createPuzzle(); // Re-shuffles and resets
        }

        startGameBtn.addEventListener('click', startGame);
        resetGameBtn.addEventListener('click', resetGame);

        // Initial setup
        createPuzzle();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game15Preview" title="Drag and Drop Puzzle Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game15')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.6s">
            <h2>16. Simple Platformer</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game16Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #6b7280;
            border: 5px solid #9ca3af;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            font-size: 1.2rem;
            color: #d1d5db;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
        .controls-info {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Platformer</h1>
        <div class="game-info">Score: <span id="score">0</span></div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
        <div class="controls-info">Controls: Arrow Keys to Move, Spacebar to Jump</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let player = {
            x: 50, y: canvas.height - 50, width: 30, height: 30,
            dx: 0, dy: 0,
            speed: 5,
            jumpStrength: -10,
            gravity: 0.5,
            onGround: false
        };

        let platforms = [
            { x: 0, y: canvas.height - 20, width: canvas.width, height: 20 }, // Ground
            { x: 100, y: canvas.height - 100, width: 150, height: 20 },
            { x: 300, y: canvas.height - 180, width: 100, height: 20 },
            { x: 450, y: canvas.height - 250, width: 120, height: 20 }
        ];

        let collectibles = [];
        let score = 0;
        let gameInterval;
        let gameActive = false;

        const keys = {};

        function drawPlayer() {
            ctx.fillStyle = '#fbd38d'; // Orange
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function drawPlatforms() {
            ctx.fillStyle = '#334155'; // Dark gray
            platforms.forEach(platform => {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });
        }

        function drawCollectibles() {
            ctx.fillStyle = '#34d399'; // Green
            collectibles.forEach(collectible => {
                ctx.beginPath();
                ctx.arc(collectible.x + collectible.radius, collectible.y + collectible.radius, collectible.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function generateCollectibles() {
            collectibles = [];
            platforms.forEach(platform => {
                if (platform.y < canvas.height - 50) { // Don't put on ground
                    for (let i = 0; i < 2; i++) { // Two collectibles per platform
                        collectibles.push({
                            x: platform.x + Math.random() * (platform.width - 20),
                            y: platform.y - 20,
                            radius: 10,
                            collected: false
                        });
                    }
                }
            });
        }

        function updateGame() {
            if (!gameActive) return;

            // Player movement
            player.x += player.dx;
            player.y += player.dy;
            player.dy += player.gravity; // Apply gravity

            player.onGround = false;

            // Collision with platforms
            platforms.forEach(platform => {
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    // Player is landing on top of platform
                    if (player.dy > 0 && player.y + player.height - player.dy <= platform.y) {
                        player.y = platform.y - player.height;
                        player.dy = 0;
                        player.onGround = true;
                    }
                    // Player hitting bottom of platform
                    else if (player.dy < 0 && player.y - player.dy >= platform.y + platform.height) {
                        player.y = platform.y + platform.height;
                        player.dy = 0;
                    }
                    // Player hitting side of platform
                    else if (player.dx > 0 && player.x + player.width - player.dx <= platform.x) {
                        player.x = platform.x - player.width;
                        player.dx = 0;
                    }
                    else if (player.dx < 0 && player.x - player.dx >= platform.x + platform.width) {
                        player.x = platform.x + platform.width;
                        player.dx = 0;
                    }
                }
            });

            // Keep player within horizontal bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // Check for falling off bottom
            if (player.y + player.height > canvas.height + 50) { // Slightly below canvas
                gameOver();
                return;
            }

            // Handle keyboard input
            player.dx = 0;
            if (keys['ArrowLeft']) {
                player.dx = -player.speed;
            }
            if (keys['ArrowRight']) {
                player.dx = player.speed;
            }
            if (keys[' '] && player.onGround) {
                player.dy = player.jumpStrength;
                player.onGround = false; // Prevent double jump
            }

            // Collectibles collision
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const c = collectibles[i];
                if (!c.collected &&
                    player.x < c.x + c.radius &&
                    player.x + player.width > c.x &&
                    player.y < c.y + c.radius &&
                    player.y + player.height > c.y) {
                    
                    score += 10;
                    scoreDisplay.textContent = score;
                    c.collected = true; // Mark as collected
                    collectibles.splice(i, 1); // Remove from array
                    parent.showMessageBox('Collected! +10 points!', 'success', 'Score!');
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlatforms();
            drawCollectibles();
            drawPlayer();

            requestAnimationFrame(updateGame);
        }

        function gameOver() {
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            parent.showMessageBox(`Game Over! Your score: ${score}`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function resetGame() {
            score = 0;
            player = {
                x: 50, y: canvas.height - 50, width: 30, height: 30,
                dx: 0, dy: 0,
                speed: 5,
                jumpStrength: -10,
                gravity: 0.5,
                onGround: false
            };
            scoreDisplay.textContent = score;
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            generateCollectibles(); // Re-generate collectibles
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlatforms();
            drawCollectibles();
            drawPlayer();
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return;
            resetGame(); // Ensure a clean start
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            updateGame();
        }

        document.addEventListener('keydown', e => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        // Touch controls
        let touchLeft = false;
        let touchRight = false;
        let touchJump = false;

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (!gameActive) return;

            const touchX = e.touches[0].clientX;
            const canvasRect = canvas.getBoundingClientRect();

            if (touchX < canvasRect.left + canvasRect.width / 3) {
                touchLeft = true;
                keys['ArrowLeft'] = true;
            } else if (touchX > canvasRect.right - canvasRect.width / 3) {
                touchRight = true;
                keys['ArrowRight'] = true;
            } else {
                touchJump = true;
                keys[' '] = true; // Simulate spacebar for jump
            }
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (!gameActive) return;

            // Reset all touch flags and keys on any touchend
            touchLeft = false;
            touchRight = false;
            touchJump = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            keys[' '] = false;
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial setup
        generateCollectibles();
        drawPlatforms();
        drawCollectibles();
        drawPlayer();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game16Preview" title="Simple Platformer Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game16')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.7s">
            <h2>17. Simple Car Racing</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game17Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Racing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #4a5568; /* Road color */
            border: 5px solid #9ca3af;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            font-size: 1.2rem;
            color: #d1d5db;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
        .controls-info {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Car Racing</h1>
        <div class="game-info">Avoid obstacles! Score: <span id="score">0</span></div>
        <canvas id="gameCanvas" width="300" height="500"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
        <div class="controls-info">Controls: Left/Right Arrow Keys or Swipe</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let playerCar = {
            x: canvas.width / 2 - 20, y: canvas.height - 80, width: 40, height: 60,
            speed: 5
        };

        let obstacles = [];
        let score = 0;
        let gameInterval;
        let gameActive = false;
        let roadSpeed = 5; // Speed at which road and obstacles move down

        const keys = {};

        function drawCar(car, color) {
            ctx.fillStyle = color;
            ctx.fillRect(car.x, car.y, car.width, car.height);
            // Draw wheels
            ctx.fillStyle = '#333';
            ctx.fillRect(car.x - 5, car.y + 10, 5, 15); // Left front
            ctx.fillRect(car.x + car.width, car.y + 10, 5, 15); // Right front
            ctx.fillRect(car.x - 5, car.y + car.height - 25, 5, 15); // Left rear
            ctx.fillRect(car.x + car.width, car.y + car.height - 25, 5, 15); // Right rear
        }

        function generateObstacle() {
            if (!gameActive) return;
            const obstacleWidth = 30 + Math.random() * 30;
            const obstacleHeight = 40 + Math.random() * 40;
            obstacles.push({
                x: Math.random() * (canvas.width - obstacleWidth),
                y: -obstacleHeight, // Start above canvas
                width: obstacleWidth,
                height: obstacleHeight,
                color: `hsl(${Math.random() * 360}, 70%, 50%)` // Random vibrant color
            });
        }

        function updateGame() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#4a5568'; // Road background
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw road lines (simplified)
            ctx.fillStyle = '#f8fafc';
            for (let i = 0; i < canvas.height; i += 40) {
                ctx.fillRect(canvas.width / 2 - 5, (i + Date.now() * 0.01 * roadSpeed) % canvas.height, 10, 20);
            }

            // Player movement
            if (keys['ArrowLeft']) {
                playerCar.x -= playerCar.speed;
            }
            if (keys['ArrowRight']) {
                playerCar.x += playerCar.speed;
            }

            // Keep player car within bounds
            if (playerCar.x < 0) playerCar.x = 0;
            if (playerCar.x + playerCar.width > canvas.width) playerCar.x = canvas.width - playerCar.width;

            drawCar(playerCar, '#3b82f6'); // Player car color (blue)

            // Update and draw obstacles
            for (let i = 0; i < obstacles.length; i++) {
                const obs = obstacles[i];
                obs.y += roadSpeed; // Move down

                drawCar(obs, obs.color); // Obstacle car color

                // Check for collision with player car
                if (playerCar.x < obs.x + obs.width &&
                    playerCar.x + playerCar.width > obs.x &&
                    playerCar.y < obs.y + obs.height &&
                    playerCar.y + playerCar.height > obs.y) {
                    gameOver();
                    return;
                }

                // Remove obstacles that are off-screen
                if (obs.y > canvas.height) {
                    obstacles.splice(i, 1);
                    i--;
                    score += 1; // Score for each obstacle passed
                    scoreDisplay.textContent = score;
                }
            }

            requestAnimationFrame(updateGame);
        }

        function gameOver() {
            gameActive = false;
            clearInterval(gameInterval);
            parent.showMessageBox(`Game Over! Your score: ${score}`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function resetGame() {
            score = 0;
            playerCar = {
                x: canvas.width / 2 - 20, y: canvas.height - 80, width: 40, height: 60,
                speed: 5
            };
            obstacles = [];
            scoreDisplay.textContent = score;
            gameActive = false;
            clearInterval(gameInterval);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCar(playerCar, '#3b82f6');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return;
            resetGame(); // Ensure a clean start
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            gameInterval = setInterval(updateGame, 1000 / 60); // 60 FPS
            setInterval(generateObstacle, 1500); // Generate new obstacle every 1.5 seconds
        }

        document.addEventListener('keydown', e => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!gameActive) return;

            const touchX = e.touches[0].clientX;
            const dx = touchX - touchStartX;
            playerCar.x += dx * 0.5; // Adjust sensitivity
            touchStartX = touchX; // Update start position for next move

            // Keep player car within bounds
            playerCar.x = Math.max(0, Math.min(canvas.width - playerCar.width, playerCar.x));
        });

        canvas.addEventListener('touchend', e => {
            // No specific action needed on touchend for continuous movement
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial draw
        drawCar(playerCar, '#3b82f6');
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game17Preview" title="Simple Car Racing Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game17')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.8s">
            <h2>18. Tower Defense</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game18Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #6b7280; /* Path color */
            border: 5px solid #9ca3af;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            display: flex;
            justify-content: space-around;
            font-size: 1.2rem;
            color: #d1d5db;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
        .tower-info {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Tower Defense</h1>
        <div class="game-info">
            <div>Gold: <span id="gold">100</span></div>
            <div>Lives: <span id="lives">10</span></div>
            <div>Wave: <span id="wave">1</span></div>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Wave</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
        <div class="tower-info">Click on empty path squares to build towers (Cost: 50 Gold)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const goldDisplay = document.getElementById('gold');
        const livesDisplay = document.getElementById('lives');
        const waveDisplay = document.getElementById('wave');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let gold = 100;
        let lives = 10;
        let wave = 0;
        let enemies = [];
        let towers = [];
        let projectiles = [];
        let gameInterval;
        let enemySpawnInterval;
        let gameActive = false;

        const cellSize = 40; // Size of each grid cell
        const path = [
            { x: 0, y: 5 }, { x: 1, y: 5 }, { x: 2, y: 5 }, { x: 3, y: 5 }, { x: 4, y: 5 }, { x: 5, y: 5 },
            { x: 5, y: 4 }, { x: 5, y: 3 }, { x: 5, y: 2 }, { x: 5, y: 1 }, { x: 5, y: 0 },
            { x: 6, y: 0 }, { x: 7, y: 0 }, { x: 8, y: 0 }, { x: 9, y: 0 }, { x: 10, y: 0 },
            { x: 10, y: 1 }, { x: 10, y: 2 }, { x: 10, y: 3 }, { x: 10, y: 4 }, { x: 10, y: 5 },
            { x: 11, y: 5 }, { x: 12, y: 5 }, { x: 13, y: 5 }, { x: 14, y: 5 }
        ]; // Grid coordinates for the path

        function drawGrid() {
            ctx.strokeStyle = '#94a3b8'; // Grid lines
            for (let i = 0; i <= canvas.width; i += cellSize) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += cellSize) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }

        function drawPath() {
            ctx.fillStyle = '#6b7280'; // Path color
            path.forEach(segment => {
                ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
            });
        }

        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(enemy.health, enemy.x, enemy.y);
        }

        function drawTower(tower) {
            ctx.fillStyle = '#34d399'; // Tower color (green)
            ctx.fillRect(tower.x - tower.size / 2, tower.y - tower.size / 2, tower.size, tower.size);
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.strokeRect(tower.x - tower.size / 2, tower.y - tower.size / 2, tower.size, tower.size);
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('T', tower.x, tower.y); // 'T' for Tower
        }

        function drawProjectile(proj) {
            ctx.fillStyle = '#fbd38d'; // Projectile color (orange)
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function spawnEnemy() {
            if (!gameActive) return;
            const startPos = path[0];
            enemies.push({
                x: startPos.x * cellSize + cellSize / 2,
                y: startPos.y * cellSize + cellSize / 2,
                radius: 10,
                health: 50 + wave * 10,
                maxHealth: 50 + wave * 10,
                speed: 1 + wave * 0.1,
                color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                pathIndex: 0
            });
        }

        function updateGame() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPath();
            drawGrid();

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.pathIndex < path.length - 1) {
                    const nextWaypoint = path[enemy.pathIndex + 1];
                    const targetX = nextWaypoint.x * cellSize + cellSize / 2;
                    const targetY = nextWaypoint.y * cellSize + cellSize / 2;

                    const dx = targetX - enemy.x;
                    const dy = targetY - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < enemy.speed) {
                        enemy.x = targetX;
                        enemy.y = targetY;
                        enemy.pathIndex++;
                    } else {
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                } else {
                    // Enemy reached end of path
                    lives--;
                    livesDisplay.textContent = lives;
                    enemies.splice(i, 1);
                    parent.showMessageBox('Enemy reached end! -1 life!', 'error', 'Lost Life!');
                }

                if (enemy.health <= 0) {
                    enemies.splice(i, 1);
                    gold += 10 + wave * 2;
                    goldDisplay.textContent = gold;
                    parent.showMessageBox('Enemy defeated! +Gold!', 'success', 'Enemy Down!');
                } else {
                    drawEnemy(enemy);
                }
            }

            // Update towers and projectiles
            towers.forEach(tower => {
                drawTower(tower);
                // Find nearest enemy
                let targetEnemy = null;
                let minDistance = Infinity;
                enemies.forEach(enemy => {
                    const dist = Math.sqrt(Math.pow(tower.x - enemy.x, 2) + Math.pow(tower.y - enemy.y, 2));
                    if (dist < tower.range && dist < minDistance) {
                        minDistance = dist;
                        targetEnemy = enemy;
                    }
                });

                if (targetEnemy && Date.now() - tower.lastShot > tower.fireRate) {
                    projectiles.push({
                        x: tower.x, y: tower.y,
                        target: targetEnemy,
                        speed: 8,
                        damage: tower.damage,
                        radius: 5
                    });
                    tower.lastShot = Date.now();
                }
            });

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                if (proj.target && proj.target.health > 0) { // Check if target still exists and is alive
                    const dx = proj.target.x - proj.x;
                    const dy = proj.target.y - proj.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < proj.speed + proj.target.radius) { // Collision with enemy
                        proj.target.health -= proj.damage;
                        projectiles.splice(i, 1);
                        i--;
                    } else {
                        proj.x += (dx / distance) * proj.speed;
                        proj.y += (dy / distance) * proj.speed;
                        drawProjectile(proj);
                    }
                } else {
                    projectiles.splice(i, 1); // Remove if target is gone or dead
                    i--;
                }
            }

            if (lives <= 0) {
                gameOver();
            }

            requestAnimationFrame(updateGame);
        }

        function gameOver() {
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            clearInterval(enemySpawnInterval);
            parent.showMessageBox(`Game Over! You survived ${wave} waves.`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Start Wave';
        }

        function resetGame() {
            gold = 100;
            lives = 10;
            wave = 0;
            enemies = [];
            towers = [];
            projectiles = [];
            goldDisplay.textContent = gold;
            livesDisplay.textContent = lives;
            waveDisplay.textContent = wave;
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            clearInterval(enemySpawnInterval);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPath();
            drawGrid();
            startButton.disabled = false;
            startButton.textContent = 'Start Wave';
        }

        function startGame() {
            if (gameActive) return;
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Wave in Progress...';
            wave++;
            waveDisplay.textContent = wave;
            let enemiesToSpawn = 5 + wave * 2;
            let spawnedCount = 0;

            enemySpawnInterval = setInterval(() => {
                if (spawnedCount < enemiesToSpawn) {
                    spawnEnemy();
                    spawnedCount++;
                } else {
                    clearInterval(enemySpawnInterval);
                    // Check if all enemies are defeated to end wave
                    const checkEnemiesInterval = setInterval(() => {
                        if (enemies.length === 0) {
                            clearInterval(checkEnemiesInterval);
                            if (gameActive) { // Only if game hasn't ended due to lives
                                parent.showMessageBox(`Wave ${wave} completed!`, 'success', 'Wave Clear!');
                                startButton.disabled = false;
                                startButton.textContent = 'Start Next Wave';
                            }
                        }
                    }, 500);
                }
            }, 1000); // Spawn enemy every second

            gameInterval = requestAnimationFrame(updateGame);
        }

        canvas.addEventListener('click', e => {
            if (!gameActive) return; // Only allow building during active game (or between waves)

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const gridX = Math.floor(clickX / cellSize);
            const gridY = Math.floor(clickY / cellSize);

            // Check if clicked cell is not on the path and not already occupied by a tower
            const isOnPath = path.some(p => p.x === gridX && p.y === gridY);
            const isTowerPresent = towers.some(t => Math.floor(t.x / cellSize) === gridX && Math.floor(t.y / cellSize) === gridY);

            if (!isOnPath && !isTowerPresent && gold >= 50) {
                towers.push({
                    x: gridX * cellSize + cellSize / 2,
                    y: gridY * cellSize + cellSize / 2,
                    size: cellSize * 0.8,
                    range: cellSize * 4, // 4 cells range
                    damage: 10,
                    fireRate: 800, // milliseconds
                    lastShot: 0
                });
                gold -= 50;
                goldDisplay.textContent = gold;
                parent.showMessageBox('Tower built! -50 Gold', 'info', 'Tower Built!');
            } else if (gold < 50) {
                parent.showMessageBox('Not enough gold to build a tower!', 'error', 'Insufficient Gold');
            } else if (isOnPath) {
                parent.showMessageBox('Cannot build on the path!', 'error', 'Invalid Location');
            } else if (isTowerPresent) {
                parent.showMessageBox('There is already a tower here!', 'error', 'Occupied');
            }
        });


        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial draw
        drawPath();
        drawGrid();
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game18Preview" title="Tower Defense Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game18')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="0.9s">
            <h2>19. Space Invaders</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game19Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #0f172a; color: #e2e8f0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .game-container {
            background-color: #1a202c;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #0f172a;
            border: 5px solid #475569;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
        }
        .game-info {
            display: flex;
            justify-content: space-around;
            font-size: 1.2rem;
            color: #94a3b8;
            margin-bottom: 1rem;
        }
        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .game-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .game-btn.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .game-btn.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
        .controls-info {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl mb-4 text-purple-300">Space Invaders</h1>
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="game-buttons">
            <button id="startButton" class="game-btn">Start Game</button>
            <button id="resetButton" class="game-btn red">Reset</button>
        </div>
        <div class="controls-info">Controls: Left/Right Arrow Keys to Move, Spacebar to Shoot</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let score = 0;
        let lives = 3;
        let gameInterval;
        let gameActive = false;

        // Player (spaceship)
        let player = {
            x: canvas.width / 2 - 25, y: canvas.height - 60, width: 50, height: 50,
            speed: 7,
            bullets: []
        };

        // Invaders
        let invaders = [];
        let invaderRows = 3;
        let invaderCols = 8;
        let invaderWidth = 30;
        let invaderHeight = 30;
        let invaderPadding = 10;
        let invaderOffsetTop = 30;
        let invaderOffsetLeft = (canvas.width - (invaderCols * (invaderWidth + invaderPadding))) / 2;
        let invaderSpeedX = 2;
        let invaderSpeedY = 15;
        let invaderBullets = [];
        let invaderShootChance = 0.005; // Chance per frame for an invader to shoot

        const keys = {};

        function drawPlayer() {
            ctx.fillStyle = '#3b82f6'; // Blue
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function drawInvader(invader) {
            ctx.fillStyle = '#ef4444'; // Red
            ctx.fillRect(invader.x, invader.y, invader.width, invader.height);
        }

        function drawBullet(bullet, color) {
            ctx.fillStyle = color;
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        }

        function createInvaders() {
            invaders = [];
            for (let r = 0; r < invaderRows; r++) {
                for (let c = 0; c < invaderCols; c++) {
                    invaders.push({
                        x: invaderOffsetLeft + c * (invaderWidth + invaderPadding),
                        y: invaderOffsetTop + r * (invaderHeight + invaderPadding),
                        width: invaderWidth,
                        height: invaderHeight,
                        dx: invaderSpeedX // Initial horizontal direction
                    });
                }
            }
        }

        function updateInvaders() {
            let hitWall = false;
            for (let i = 0; i < invaders.length; i++) {
                const invader = invaders[i];
                invader.x += invader.dx;

                if (invader.x + invader.width > canvas.width || invader.x < 0) {
                    hitWall = true;
                }

                // Invader shooting
                if (gameActive && Math.random() < invaderShootChance) {
                    invaderBullets.push({
                        x: invader.x + invader.width / 2 - 2,
                        y: invader.y + invader.height,
                        width: 4,
                        height: 10,
                        speed: 5
                    });
                }

                // Check if invader reached player's level
                if (invader.y + invader.height > player.y) {
                    gameOver();
                    return;
                }
            }

            if (hitWall) {
                invaders.forEach(invader => {
                    invader.dx *= -1; // Reverse horizontal direction
                    invader.y += invaderSpeedY; // Move down
                });
            }
        }

        function updateBullets() {
            // Player bullets
            for (let i = player.bullets.length - 1; i >= 0; i--) {
                const bullet = player.bullets[i];
                bullet.y -= bullet.speed;

                // Check collision with invaders
                for (let j = invaders.length - 1; j >= 0; j--) {
                    const invader = invaders[j];
                    if (bullet.x < invader.x + invader.width &&
                        bullet.x + bullet.width > invader.x &&
                        bullet.y < invader.y + invader.height &&
                        bullet.y + bullet.height > invader.y) {
                        
                        invaders.splice(j, 1); // Remove invader
                        player.bullets.splice(i, 1); // Remove bullet
                        score += 10;
                        scoreDisplay.textContent = score;
                        parent.showMessageBox('Invader hit! +10 points!', 'success', 'Hit!');
                        break; // Bullet is gone, move to next bullet
                    }
                }

                if (bullet.y < 0) { // Bullet off screen
                    player.bullets.splice(i, 1);
                }
            }

            // Invader bullets
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                const bullet = invaderBullets[i];
                bullet.y += bullet.speed;

                // Check collision with player
                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    lives--;
                    livesDisplay.textContent = lives;
                    invaderBullets.splice(i, 1); // Remove bullet
                    parent.showMessageBox('You were hit! -1 life!', 'error', 'Hit!');
                    if (lives <= 0) {
                        gameOver();
                        return;
                    }
                }

                if (bullet.y > canvas.height) { // Bullet off screen
                    invaderBullets.splice(i, 1);
                }
            }
        }

        function shootPlayerBullet() {
            if (!gameActive) return;
            player.bullets.push({
                x: player.x + player.width / 2 - 2,
                y: player.y,
                width: 4,
                height: 10,
                speed: 8
            });
        }

        function gameLoop() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Player movement
            if (keys['ArrowLeft']) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight']) {
                player.x += player.speed;
            }
            // Keep player within bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            updateInvaders();
            updateBullets();

            drawPlayer();
            invaders.forEach(drawInvader);
            player.bullets.forEach(bullet => drawBullet(bullet, '#fbd38d')); // Player bullets orange
            invaderBullets.forEach(bullet => drawBullet(bullet, '#f87171')); // Invader bullets red

            if (invaders.length === 0) {
                gameWin();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        function gameWin() {
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            parent.showMessageBox('You defeated all invaders! You Win!', 'success', 'Victory!');
            startButton.disabled = false;
            startButton.textContent = 'Play Again';
        }

        function gameOver() {
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            parent.showMessageBox(`Game Over! Your score: ${score}`, 'info', 'Game Over!');
            startButton.disabled = false;
            startButton.textContent = 'Play Again';
        }

        function resetGame() {
            score = 0;
            lives = 3;
            player.x = canvas.width / 2 - 25;
            player.bullets = [];
            invaderBullets = [];
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            gameActive = false;
            cancelAnimationFrame(gameInterval);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();
            createInvaders(); // Re-create invaders for reset
            invaders.forEach(drawInvader);
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return;
            resetGame(); // Ensure a clean start
            gameActive = true;
            startButton.disabled = true;
            startButton.textContent = 'Playing...';
            gameLoop();
        }

        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === ' ') { // Spacebar
                shootPlayerBullet();
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveInterval;

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (!gameActive) return;

            const touchX = e.touches[0].clientX;
            const canvasRect = canvas.getBoundingClientRect();

            // If touch is on the left/right quarter, initiate movement
            if (touchX < canvasRect.left + canvasRect.width / 4) {
                keys['ArrowLeft'] = true;
            } else if (touchX > canvasRect.right - canvasRect.width / 4) {
                keys['ArrowRight'] = true;
            } else {
                // Otherwise, it's a shoot action
                shootPlayerBullet();
            }
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (!gameActive) return;
            // Stop movement on touch release
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });

        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial setup
        createInvaders();
        drawPlayer();
        invaders.forEach(drawInvader);
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game19Preview" title="Space Invaders Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game19')">Play Game</button>
            </div>
        </section>

        <section class="game-card wow animate__animated animate__fadeInUp" data-wow-delay="1.0s">
            <h2>20. Simple Drawing App</h2>
            <div class="code-preview-container">
                <div class="code-editor">
                    <textarea id="game20Code">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body { font-family: 'Roboto Mono', monospace; background-color: #1f2937; color: #f9fafb; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; }
        .drawing-container {
            background-color: #374151;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        canvas {
            background-color: #ffffff;
            border: 5px solid #9ca3af;
            border-radius: 0.75rem;
            display: block;
            margin: 1.5rem auto;
            cursor: crosshair;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .control-label {
            font-size: 0.9rem;
            color: #d1d5db;
        }
        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            padding: 0;
            overflow: hidden;
        }
        input[type="range"] {
            width: 100px;
            -webkit-appearance: none;
            height: 8px;
            background: #6b7280;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
        }
        .control-button {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            outline: none;
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16,185,129,0.5);
        }
        .control-button.red {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
        }
        .control-button.red:hover {
            box-shadow: 0 8px 20px rgba(239,68,68,0.5);
        }
    </style>
</head>
<body>
    <div class="drawing-container">
        <h1 class="text-4xl mb-4 text-purple-300">Simple Drawing App</h1>
        <canvas id="drawingCanvas" width="600" height="400"></canvas>
        <div class="controls">
            <div class="control-group">
                <label for="colorPicker" class="control-label">Color:</label>
                <input type="color" id="colorPicker" value="#6366f1">
            </div>
            <div class="control-group">
                <label for="brushSize" class="control-label">Size:</label>
                <input type="range" id="brushSize" min="1" max="20" value="5">
            </div>
            <button id="clearCanvasBtn" class="control-button red">Clear</button>
            <button id="saveDrawingBtn" class="control-button">Save</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeSlider = document.getElementById('brushSize');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const saveDrawingBtn = document.getElementById('saveDrawingBtn');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Initial settings
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = brushSizeSlider.value;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getCoordinates(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            [lastX, lastY] = getCoordinates(e);
            ctx.lineTo(lastX, lastY);
            ctx.stroke();
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches && e.touches.length > 0) { // Touch event
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else { // Mouse event
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return [clientX - rect.left, clientY - rect.top];
        }

        // Event Listeners for drawing
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing); // Stop drawing if mouse leaves canvas

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        // Control listeners
        colorPicker.addEventListener('input', () => {
            ctx.strokeStyle = colorPicker.value;
        });

        brushSizeSlider.addEventListener('input', () => {
            ctx.lineWidth = brushSizeSlider.value;
        });

        clearCanvasBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            parent.showMessageBox('Canvas cleared!', 'info', 'Cleared');
        });

        saveDrawingBtn.addEventListener('click', () => {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'my-drawing.png';
            link.href = dataURL;
            link.click();
            parent.showMessageBox('Drawing saved as image!', 'success', 'Saved!');
        });
    </script>
</body>
</html>
                    </textarea>
                </div>
                <div class="live-preview">
                    <iframe id="game20Preview" title="Simple Drawing App Preview"></iframe>
                </div>
            </div>
            <div class="button-group">
                <button onclick="loadGame('game20')">Open App</button>
            </div>
        </section>

    </main>

    <div id="messageBox" class="message-box-overlay">
        <div class="message-box-content">
            <h3 id="messageBoxTitle" class="text-xl font-semibold mb-3 text-slate-800 dark:text-slate-200"></h3>
            <p id="messageBoxText" class="text-slate-700 dark:text-slate-300"></p>
            <button id="messageBoxCloseBtn" class="message-box-button">OK</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            new WOW().init();

            // Message Box Functionality (copied from template.html for consistency)
            const messageBox = document.getElementById('messageBox');
            const messageBoxTitle = document.getElementById('messageBoxTitle');
            const messageBoxText = document.getElementById('messageBoxText');
            const messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');

            window.showMessageBox = function(message, type = 'info', title = 'Notification') {
                messageBoxTitle.textContent = title;
                messageBoxText.textContent = message;
                if (type === 'success') {
                    messageBoxTitle.style.color = '#10b981';
                } else if (type === 'error') {
                    messageBoxTitle.style.color = '#ef4444';
                } else {
                    messageBoxTitle.style.color = '';
                }
                messageBox.classList.add('open');
                document.body.style.overflow = 'hidden';
            }

            messageBoxCloseBtn.addEventListener('click', () => {
                messageBox.classList.remove('open');
                document.body.style.overflow = '';
            });

            messageBox.addEventListener('click', (e) => {
                if (e.target === messageBox) {
                    messageBox.classList.remove('open');
                    document.body.style.overflow = '';
                }
            });

            // Function to load game code into iframe
            window.loadGame = function(gameId) {
                const codeTextarea = document.getElementById(`${gameId}Code`);
                const previewIframe = document.getElementById(`${gameId}Preview`);

                if (codeTextarea && previewIframe) {
                    const htmlContent = codeTextarea.value;
                    const doc = previewIframe.contentWindow.document;

                    doc.open();
                    doc.write(htmlContent);
                    doc.close();
                } else {
                    showMessageBox('Error: Game elements not found.', 'error');
                }
            };

            // Automatically load the first game on page load
            loadGame('game1');
            loadGame('game2');
            loadGame('game3');
            loadGame('game4');
            loadGame('game5');
            loadGame('game6');
            loadGame('game7');
            loadGame('game8');
            loadGame('game9');
            loadGame('game10');
            loadGame('game11');
            loadGame('game12');
            loadGame('game13');
            loadGame('game14');
            loadGame('game15');
            loadGame('game16');
            loadGame('game17');
            loadGame('game18');
            loadGame('game19');
            loadGame('game20');
        });
    </script>
</body>
</html>
